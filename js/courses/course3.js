const lessonContainer = document.getElementById("lesson-container");
const lessonsGrid = document.getElementById("lessons-grid");
const lessonsContent = {
    "lesson1": "<h2>Урок 1 – Декоратори та оптимізація коду</h2>\n<p>Декоратори дозволяють обгортати функції або класи додатковою логікою без зміни їхнього коду. Це зручно для повторного використання та оптимізації.</p>\n\n<h3>Основні можливості:</h3>\n<ul>\n<li>Логування викликів функцій.</li>\n<li>Кешування результатів для підвищення швидкодії.</li>\n<li>Перевірка доступу або прав користувача.</li>\n<li>Вимірювання часу виконання.</li>\n</ul>\n\n<h3>Приклад:</h3>\n<pre><code>def logger(func):\n    def wrapper(*args, **kwargs):\n        print(f'Виклик функції {func.__name__}')\n        return func(*args, **kwargs)\n    return wrapper\n\n@logger\ndef greet(name):\n    return f'Привіт, {name}!'\n\nprint(greet('Артем'))</code></pre>\n\n<p>✅ <strong>Мета:</strong> студенти повинні навчитися:</p>\n<ul>\n<li>Створювати власні декоратори.</li>\n<li>Оптимізувати код за допомогою кешування та логування.</li>\n<li>Розуміти принцип «обгортання функцій».</li>\n</ul><!-- Бібліотека: functools -->",

    "lesson2": "<h2>Урок 2 – Git та GitHub: співпраця у репозиторіях, якими ви не володієте</h2>\n<p>Git — система контролю версій; GitHub — сервіс для хостингу та організації співпраці через форки, гілки та pull request (PR). Тут детально про workflow, синхронізацію з upstream та роботу як contributor або collaborator.</p>\n\n<h3>Підходи до співпраці</h3>\n<ul>\n<li><strong>Fork + Pull Request</strong> — стандарт, коли у вас немає прав: форк робиться у вашому акаунті, ви пушите у форк і відкриваєте PR до оригіналу.</li>\n<li><strong>Branch в оригінальному репозиторії</strong> — якщо вам надали права collaborator, ви створюєте гілку напряму і пушите туди; далі PR або merge.</li>\n<li><strong>Patch / Issue</strong> — для дуже малих змін можна надіслати патч або пропозицію в issue.</li>\n</ul>\n\n<h3>Типовий workflow через fork (покроково)</h3>\n<pre><code># Форкаємо на GitHub, потім локально:\ngit clone git@github.com:your-username/repo.git\ncd repo\n# Додаємо upstream (оригінал) для синхронізації\ngit remote add upstream git@github.com:original-owner/repo.git\n# Переконайтесь у списку remote\ngit remote -v\n# Створюємо фічеву гілку\ngit checkout -b feature/your-feature\n# Працюємо, додаємо, комітимо\ngit add .\ngit commit -m \"feat: короткий опис\"\n# Пушимо в свій форк\ngit push origin feature/your-feature\n# Створюємо Pull Request з вашої гілки у гілку проєкту (наприклад main)\n</code></pre>\n\n<h3>Як синхронізуватися з upstream (щоб уникнути конфліктів)</h3>\n<pre><code># Оновити локальну main з upstream\ngit checkout main\ngit fetch upstream\ngit merge upstream/main\n# Або, якщо хочете чистішу історію, rebase\ngit checkout feature/your-feature\ngit fetch upstream\ngit rebase upstream/main\n# Після rebase може знадобитись push з форсом (робіть --force-with-lease)\ngit push origin feature/your-feature --force-with-lease\n</code></pre>\n\n<h3>Практика роботи з PR — чекліст</h3>\n<ul>\n<li>Дотримуйтесь CONTRIBUTING.md та шаблонів (якщо є).</li>\n<li>Опис PR: що змінено, чому, як тестувати; додавайте короткі та змістовні коміти.</li>\n<li>Запускайте локальні тести і lint перед пушем; якщо в проекті є CI (наприклад GitHub Actions) — дивіться логи PR.</li>\n<li>Оновлюйте гілку з upstream (merge або rebase) перед тим, як просити merge.</li>\n<li>Виконуйте правки на основі code review; пояснюйте зміни у коментарях PR.</li>\n</ul>\n\n<h3>Вирішення конфліктів</h3>\n<p>Якщо під час merge/rebase виникають конфлікти: знайдіть маркери <<<<<<<, =======, >>>>>>>, вручну виправте код, потім `git add <file>` і `git rebase --continue` або зробіть commit після merge. Завжди тестуйте після вирішення конфліктів.</p>\n\n<h3>Best practices та поради</h3>\n<ul>\n<li>Короткі, сфокусовані гілки для однієї задачі: `feature/issue-123`, `fix/typo`.</li>\n<li>Використовуйте `--force-with-lease` замість `--force` для безпечнішого переписування історії.</li>\n<li>Не пуште секрети; використовуйте `.gitignore` і GitHub Secrets для CI.</li>\n<li>Якщо проект вимагає підписані коміти — налаштуйте GPG або SSH підписи.</li>\n<li>Уточніть стратегію злиття (merge commit, squash merge або rebase) у команді — це впливає на історію.</li>\n<li>Перевіряйте файли `CONTRIBUTING.md`, `CODEOWNERS`, шаблони PR/issue — вони задають правила проєкту.</li>\n</ul>\n\n<h3>Шпаргалка команд</h3>\n<pre><code>git status\ngit add <file>\ngit commit -m \"msg\"\ngit push origin <branch>\ngit fetch upstream\ngit merge upstream/main\n# або\ngit rebase upstream/main\ngit pull --rebase upstream main\n</code></pre>\n\n<p>✅ <strong>Мета:</strong> навчитися ефективно працювати через fork і PR, синхронізувати гілки з upstream, безпечно вирішувати конфлікти, дотримуватись правил проєкту та проходити код-рев'ю.</p>\n\n<!-- Бібліотека: Git, GitHub, GitHub Actions -->",

    "lesson3": "<h2>Урок 3 – Створення слайдера та контроль версій з Git</h2>\n<p>Слайдер — це елемент інтерфейсу, який дозволяє перегортати зображення або контент. Ми поєднаємо його створення з практикою з Git, щоб навчитися фіксувати версії змін у коді.</p>\n\n<h3>Реалізація простого слайдера</h3>\n<pre><code>&lt;div class=\"slider\"&gt;\n  &lt;div class=\"slide active\"&gt;1&lt;/div&gt;\n  &lt;div class=\"slide\"&gt;2&lt;/div&gt;\n  &lt;div class=\"slide\"&gt;3&lt;/div&gt;\n  &lt;button id=\"prev\"&gt;◀&lt;/button&gt;\n  &lt;button id=\"next\"&gt;▶&lt;/button&gt;\n&lt;/div&gt;\n\n&lt;script&gt;\nconst slides = document.querySelectorAll('.slide');\nlet index = 0;\n\nfunction showSlide(i) {\n  slides.forEach(s => s.classList.remove('active'));\n  slides[i].classList.add('active');\n}\n\ndocument.getElementById('next').onclick = () => {\n  index = (index + 1) % slides.length;\n  showSlide(index);\n}\ndocument.getElementById('prev').onclick = () => {\n  index = (index - 1 + slides.length) % slides.length;\n  showSlide(index);\n}\n&lt;/script&gt;\n\n&lt;style&gt;\n.slider { position: relative; width: 300px; height: 200px; overflow: hidden; }\n.slide { display: none; text-align: center; font-size: 2em; line-height: 200px; }\n.slide.active { display: block; background: #eee; }\n&lt;/style&gt;\n</code></pre>\n\n<h3>Практика з Git</h3>\n<ol>\n<li>Ініціалізація репозиторію: <code>git init</code>.</li>\n<li>Додавання файлів: <code>git add .</code>.</li>\n<li>Створення першого коміту: <code>git commit -m \"add slider base\"</code>.</li>\n<li>Створення нової гілки для фічі: <code>git checkout -b feature/slider</code>.</li>\n<li>Після змін — знову <code>git add .</code> і <code>git commit -m \"feat: slider navigation\"</code>.</li>\n<li>Пушимо в GitHub: <code>git push origin feature/slider</code>.</li>\n<li>Створюємо Pull Request, щоб змерджити фічу в основну гілку.</li>\n</ol>\n\n<h3>Поєднання теорії</h3>\n<ul>\n<li>Слайдер = приклад фронтенд-фічі.</li>\n<li>Git = контроль версій, збереження історії, колаборація.</li>\n<li>Кожна зміна (наприклад, додавання кнопок або анімації) — це окремий коміт.</li>\n</ul>\n\n<p>✅ <strong>Мета:</strong> навчитися створювати простий слайдер на JavaScript, зберігати зміни через Git, організовувати роботу з гілками та Pull Request.</p>\n\n<!-- Технології: Git, JavaScript -->",

    "lesson4": "<h2>Урок 4 – Мультимовність (i18n)</h2>\n<p>Мультимовність (i18n) дозволяє створювати інтерфейси, які підтримують кілька мов. Це важливо для міжнародних проектів та зручності користувачів.</p>\n\n<h3>Підходи до реалізації</h3>\n<ul>\n<li><strong>JSON-файли з перекладами</strong> – кожна мова має свій файл: <code>en.json</code>, <code>uk.json</code>, <code>es.json</code>.</li>\n<li><strong>Бібліотеки</strong> – наприклад <code>i18next</code> або <code>react-intl</code> для React.</li>\n<li><strong>Динамічне перемикання</strong> – користувач може змінювати мову через селектор.</li>\n<li><strong>Зберігання вибору</strong> – у LocalStorage або cookies, щоб пам’ятати мову.</li>\n</ul>\n\n<h3>Приклад структури перекладів</h3>\n<pre><code>// en.json\n{\n  \"hello\": \"Hello\",\n  \"welcome\": \"Welcome to our site\"\n}\n\n// uk.json\n{\n  \"hello\": \"Привіт\",\n  \"welcome\": \"Ласкаво просимо на наш сайт\"\n}\n</code></pre>\n\n<h3>Приклад використання у JavaScript</h3>\n<pre><code>import i18next from 'i18next';\n\n// Ініціалізація\ni18next.init({\n  lng: 'uk', // поточна мова\n  resources: {\n    en: { translation: { hello: 'Hello' } },\n    uk: { translation: { hello: 'Привіт' } }\n  }\n});\n\n// Отримання перекладу\nconsole.log(i18next.t('hello')); // Привіт\n</code></pre>\n\n<h3>Best practices</h3>\n<ul>\n<li>Не хардкодьте тексти у компонентах – завжди використовуйте переклади.</li>\n<li>Організовуйте переклади у тематичні файли: <code>auth.json</code>, <code>navbar.json</code>.</li>\n<li>Використовуйте fallback мову, якщо переклад відсутній.</li>\n<li>Завжди тестуйте відображення для мов з різною довжиною слів (наприклад, англійська vs німецька).</li>\n</ul>\n\n<p>✅ <strong>Мета:</strong> навчитися будувати багатомовний інтерфейс, підключати бібліотеку i18n, організовувати переклади та забезпечувати зручність перемикання мов.</p>\n\n<!-- Технології: i18next, react-intl -->",

    "lesson5": "<h2>Урок 5 – Валідація форми з JustValidate</h2>\n<p>Валідація форми потрібна для перевірки правильності введених даних ще до відправки на сервер. Бібліотека <code>JustValidate</code> дозволяє робити це просто і зручно.</p>\n\n<h3>Основні можливості JustValidate</h3>\n<ul>\n<li>Перевірка обов’язкових полів.</li>\n<li>Валідація email, паролів, номерів телефону.</li>\n<li>Кастомні повідомлення про помилки.</li>\n<li>Можливість створення власних правил.</li>\n</ul>\n\n<h3>HTML приклад</h3>\n<pre><code>&lt;form id=\"signup\"&gt;\n  &lt;input type=\"text\" name=\"name\" placeholder=\"Ваше ім'я\" /&gt;\n  &lt;input type=\"email\" name=\"email\" placeholder=\"Email\" /&gt;\n  &lt;input type=\"password\" name=\"password\" placeholder=\"Пароль\" /&gt;\n  &lt;button type=\"submit\"&gt;Надіслати&lt;/button&gt;\n&lt;/form&gt;\n</code></pre>\n\n<h3>JS приклад з JustValidate</h3>\n<pre><code>import JustValidate from 'just-validate';\n\nconst validator = new JustValidate('#signup');\n\nvalidator\n  .addField('[name=\"name\"]', [\n    { rule: 'required', errorMessage: 'Введіть ім’я' },\n    { rule: 'minLength', value: 3, errorMessage: 'Мінімум 3 символи' }\n  ])\n  .addField('[name=\"email\"]', [\n    { rule: 'required', errorMessage: 'Email обов’язковий' },\n    { rule: 'email', errorMessage: 'Некоректний email' }\n  ])\n  .addField('[name=\"password\"]', [\n    { rule: 'required', errorMessage: 'Введіть пароль' },\n    { rule: 'password', errorMessage: 'Пароль повинен містити цифри та букви' }\n  ]);\n</code></pre>\n\n<h3>Best practices</h3>\n<ul>\n<li>Поєднуйте клієнтську та серверну валідацію (безпека перш за все).</li>\n<li>Використовуйте зрозумілі повідомлення для користувачів.</li>\n<li>Не робіть форму занадто суворою, залишайте простір для різних форматів (наприклад, телефонів).</li>\n<li>Додавайте валідацію ще на етапі UX (placeholder, підказки).</li>\n</ul>\n\n<p>✅ <strong>Мета:</strong> навчитися підключати JustValidate, додавати правила до полів форми, відображати помилки та покращувати UX користувачів.</p>\n\n<!-- Бібліотека: JustValidate -->",

    "lesson6": "<h2>Урок 6 – AJAX, JSON та Git: запити на сервер, DNS, HTTP/HTTPS, асинхронний/синхронний код, мікро- та макротаски</h2>\n<p>Цей урок охоплює всі рівні: як браузер відправляє запит (DNS → TCP/TLS → HTTP), які є способи комунікації (AJAX, fetch, XHR, WebSocket, SSE), як працює формат JSON, як обробляти відповіді та помилки, що таке синхронний/асинхронний код, та як розуміти мікро- і макротаски в event loop. Наприкінці — практичні поради по Git (що і як комітити, де зберігати ключі).</p>\n\n<h3>1) Основні способи комунікації клієнт↔сервер</h3>\n<ul>\n<li><strong>Класичні HTTP-запити</strong> (request/response): GET/POST/PUT/PATCH/DELETE/HEAD/OPTIONS.</li>\n<li><strong>AJAX</strong> — загальне поняття: робота з HTTP без перезавантаження сторінки; реалізації: <code>XMLHttpRequest</code> (старіший) і <code>Fetch API</code> (сучасний).</li>\n<li><strong>HTTP-бібліотеки</strong> — приклад назви: axios (зручніший API, інтерсептори для токенів).</li>\n<li><strong>Реальні-time варіанти</strong>: Polling, Long-polling, Server-Sent Events (SSE) для однонаправлених оновлень, WebSocket для двонаправленої комунікації, WebRTC для P2P медіа/даних.</li>\n</ul>\n\n<h3>2) HTTP-методи та семантика</h3>\n<ul>\n<li><code>GET</code> — читання (safe, idempotent).</li>\n<li><code>POST</code> — створення/операції (не idempotent).</li>\n<li><code>PUT</code> — заміна ресурсу (idempotent).</li>\n<li><code>PATCH</code> — часткове оновлення.</li>\n<li><code>DELETE</code> — видалення (idempotent).</li>\n<li><code>HEAD</code> — як GET, але без тіла; <code>OPTIONS</code> — дізнатися дозволи/для CORS preflight.</li>\n</ul>\n\n<h3>3) Приклад: відправка JSON через Fetch (async/await)</h3>\n<pre><code>const payload = { name: 'Artem' };\ntry {\n  const res = await fetch('/api/users', {\n    method: 'POST',\n    headers: { 'Content-Type': 'application/json', 'Accept': 'application/json' },\n    body: JSON.stringify(payload)\n  });\n  if (!res.ok) throw new Error(`HTTP ${res.status}`);\n  const json = await res.json();\n  console.log('server response', json);\n} catch (err) {\n  console.error('request failed', err);\n}\n</code></pre>\n<p>Порада: завжди перевіряйте <code>res.ok</code> / код статусу; мережеві помилки кидають виняток (catch).</p>\n\n<h3>4) XMLHttpRequest (async vs sync) — коротко</h3>\n<pre><code>// asynchronous\nconst xhr = new XMLHttpRequest();\nxhr.open('GET', '/api/data', true);\nxhr.onload = () => { if (xhr.status === 200) console.log(JSON.parse(xhr.responseText)); };\nxhr.onerror = () => { console.error('network error'); };\nxhr.send();\n\n// synchronous (deprecated on main thread — блокує UI)\nxhr.open('GET', '/api/data', false);\nxhr.send(null);\nconsole.log(xhr.responseText);\n</code></pre>\n<p>Не використовуйте синхронні запити у UI — вони блокують event loop і роблять сторінку нефункціональною.</p>\n\n<h3>5) CORS і preflight</h3>\n<p>Якщо запит використовує нестандартні заголовки, методи (PUT, DELETE, PATCH) або Content-Type відмінний від простих типів, браузер спочатку відправляє OPTIONS (preflight). Сервер має відповісти з заголовками <code>Access-Control-Allow-Origin</code>, <code>Access-Control-Allow-Methods</code>, <code>Access-Control-Allow-Headers</code> щоб дозвілити запит.</p>\n\n<h3>6) HTTP статуси (коротко)</h3>\n<ul>\n<li>1xx — інформативні</li>\n<li>2xx — успіх (200 OK, 201 Created, 204 No Content)</li>\n<li>3xx — редиректи (301, 302, 304)</li>\n<li>4xx — помилки клієнта (400, 401, 403, 404, 409, 429)</li>\n<li>5xx — помилки сервера (500, 502, 503)</li>\n</ul>\n\n<h3>7) JSON — робота</h3>\n<pre><code>// JS -> сервер\nconst str = JSON.stringify({ foo: 'bar' });\n// Отримали від сервера\nconst obj = await response.json();\n</code></pre>\n<p>JSON — текстовий формат; перевіряйте вхідні дані на сервері (серверна валідація) та не довіряйте клієнтським перевіркам.</p>\n\n<h3>8) DNS: як домен → IP (по кроках)</h3>\n<ol>\n<li>Вводите example.com у браузері.</li>\n<li>Браузер/ОС перевіряє локальний кеш і /etc/hosts.</li>\n<li>Якщо немає — запит іде до DNS-резолвера (часто — провайдер або системний DNS, recursive resolver).</li>\n<li>Резолвер запитує root-сервер → повертає TLD nameserver (.com) → TLD повертає авторитетний nameserver для example.com → авторитетний повертає A/AAAA запис (IP).</li>\n<li>IP повертається клієнту і кешується (TTL визначає час кешування).</li>\n</ol>\n<p>Пояснення термінів: <strong>NS record</strong> — вказує, які nameserver-и є авторитетними для зони; <strong>resolver</strong> — той, хто робить рекурсивний пошук (може кешувати відповіді).</p>\n\n<h3>9) HTTP vs HTTPS — TLS (коротко, але з ключовими кроками)</h3>\n<ul>\n<li>HTTP — передача у відкритому тексті (порт 80).</li>\n<li>HTTPS — HTTP поверх TLS/SSL (порт 443): TLS handshake (ClientHello → ServerHello → сертифікат → перевірка ланцюжка довіри → ключовий обмін (ECDHE) → встановлення симетричного ключа) → зашифровані дані.</li>\n<li>Сертифікат підписаний CA; браузер довіряє лише сертифікатам від довірених кореневих CA. TLS забезпечує конфіденційність та цілісність (захист від MITM).</li>\n<li>HTTP/2 — мультиплексування, бінарний фреймінг, стиснення заголовків; HTTP/3 — QUIC поверх UDP (швидше відновлення, менша латентність).</li>\n</ul>\n\n<h3>10) Асинхронний vs синхронний код у JS</h3>\n<ul>\n<li><strong>Синхронний код</strong> виконується послідовно і блокує call stack до завершення (напр., важкий цикл, синхронний XHR на головному потоці) — користувач бачить зависання сторінки.</li>\n<li><strong>Асинхронний код</strong> (callbacks, Promises, async/await, fetch, setTimeout) дозволяє виконувати довгі операції без блокування головного потоку: операція запускається, а потім її результат обробляється колбеком або Promise-обробником.</li>\n<li><strong>await</strong> зупиняє виконання лише всередині async-функції (не блокує весь event loop).</li>\n</ul>\n\n<h3>11) Event loop: макро- і мікротаски (порядок виконання)</h3>\n<p>Коротка модель: <code>call stack</code> виконує поточний скрипт → коли скрипт завершується, браузер обробляє усі мікротаски → можливий рендер/paint → потім витягується наступна макротаска з черги завдань.</p>\n<ul>\n<li><strong>Мікротаски</strong> (microtasks): Promise.then/catch/finally, queueMicrotask, MutationObserver — виконуються швидко після поточної таски і перед наступним рендером/макротаскою.</li>\n<li><strong>Макротаски</strong> (tasks): setTimeout, setInterval, I/O callbacks, UI events — кожна така таска виконується окремо; після неї чиститься мікротаск-черга.</li>\n<li>Результат: Promise callbacks завжди виконуються раніше, ніж setTimeout(..., 0) навіть якщо вони були поставлені після виклику setTimeout.</li>\n</ul>\n<pre><code>console.log('script start');\nsetTimeout(() =&gt; console.log('macrotask'), 0);\nPromise.resolve().then(() =&gt; console.log('microtask'));\nconsole.log('script end');\n// Порядок: script start, script end, microtask, macrotask\n</code></pre>\n<p>Нотатка для Node.js: модель подібна, але є свої черги і додаткові примітки (process.nextTick має вищий пріоритет поряд з мікротасками); не забудь читати документацію Node щодо порядку черг, якщо пишеш під сервер.</p>\n\n<h3>12) Надійність, таймаути, retry, backoff</h3>\n<ul>\n<li>Додавайте таймаути для мережевих запитів (fetch має timeout треба реалізовувати через AbortController).</li>\n<li>Реалізуйте retry з експоненціальним backoff для тимчасових помилок (429, 5xx).</li>\n<li>Логи та метрики: реєструйте помилки запитів для аналізу (не комітьте ключі у репо!).</li>\n</ul>\n\n<h3>13) Безпека: секрети, токени, CSRF, XSS</h3>\n<ul>\n<li>Не зберігайте секрети в коді — використовуй .env і додавай .env до .gitignore.</li>\n<li>Для авторизації: використовуй Authorization: Bearer &lt;token&gt; або HttpOnly cookies (щоб уникнути XSS-крадіжки токенів).</li>\n<li>CSRF: для state-changing запитів використовуйте CSRF-токени або SameSite cookies.</li>\n<li>Санітизуй дані на сервері та фільтруй/екрануй вихідний HTML, щоб уникнути XSS.</li>\n</ul>\n\n<h3>14) Git-поради при роботі з API-кодом</h3>\n<ul>\n<li>Не комітьте ключі/сертифікати — додайте <code>.env</code> у <code>.gitignore</code> і збережіть шаблон <code>.env.example</code>.</li>\n<li>Комітіть короткими, атомарними змінами: <code>git commit -m \"feat(api): add fetch wrapper with timeout\"</code>.</li>\n<li>Використовуйте фічеві гілки: <code>feature/add-api-client</code> і PR для рев'ю.</li>\n<li>Якщо потрібно переключитися гілку — користуйтесь <code>git stash</code> або робіть commit у тимчасову гілку.</li>\n<li>Тести запитів локально з curl/httpie/Postman (назви інструментів) і додавайте інтеграційні/мок-тести на CI.</li>\n</ul>\n\n<h3>15) Короткі коди-гаки (корисні приклади)</h3>\n<pre><code>// Fetch + timeout через AbortController\nconst controller = new AbortController();\nconst id = setTimeout(() =&gt; controller.abort(), 5000); // 5s timeout\ntry {\n  const res = await fetch('/api', { signal: controller.signal });\n  clearTimeout(id);\n  const data = await res.json();\n} catch (err) {\n  if (err.name === 'AbortError') console.warn('timeout');\n}\n\n// axios interceptor (назва бібліотеки: axios)\naxios.interceptors.request.use(cfg =&gt; { cfg.headers.Authorization = `Bearer ${getToken()}`; return cfg; });\n\n// Простий exponential backoff\nasync function retry(fn, retries = 3) {\n  let attempt = 0;\n  while (attempt &lt;= retries) {\n    try { return await fn(); } catch (e) {\n      attempt++;\n      await new Promise(r =&gt; setTimeout(r, 2 ** attempt * 100));\n    }\n  }\n  throw new Error('all retries failed');\n}\n</code></pre>\n\n<p>✅ <strong>Мета:</strong> зрозуміти як працює мережа від доменного імені до зашифрованого HTTP-запиту, знати основні способи обміну даними (JSON), правильно обробляти помилки, використовувати асинхронні інструменти JS, розуміти порядок виконання (мікро/макро таски) і безпечно керувати кодом у Git (не зберігати секрети, робити фічеві гілки, тестувати запити).</p>\n\n<!-- Технології: Fetch API, XMLHttpRequest, axios, WebSocket, SSE, Git -->",

    "lesson7": "<h2>Урок 7 – Promise</h2>\n<p><code>Promise</code> – це об’єкт у JavaScript, який представляє результат асинхронної операції: виконану (fulfilled), відхилену (rejected) або ще очікувану (pending). Він дозволяє зручно працювати з асинхронним кодом без вкладених колбеків («callback hell»).</p>\n\n<h3>Стани Promise</h3>\n<ul>\n<li><strong>pending</strong> – очікування (операція ще виконується).</li>\n<li><strong>fulfilled</strong> – успішно виконано.</li>\n<li><strong>rejected</strong> – сталася помилка.</li>\n</ul>\n\n<h3>Створення Promise</h3>\n<pre><code>const myPromise = new Promise((resolve, reject) => {\n  setTimeout(() => {\n    const success = true;\n    if (success) {\n      resolve('Дані завантажені');\n    } else {\n      reject('Помилка завантаження');\n    }\n  }, 1000);\n});</code></pre>\n\n<h3>Обробка результату</h3>\n<pre><code>myPromise\n  .then(result => console.log(result)) // викликається при resolve\n  .catch(error => console.error(error)) // викликається при reject\n  .finally(() => console.log('Завершено'));</code></pre>\n\n<h3>Ланцюжки Promise</h3>\n<pre><code>fetch('data.json')\n  .then(response => response.json())\n  .then(data => console.log(data))\n  .catch(err => console.error(err));</code></pre>\n\n<h3>Promise.all / Promise.race</h3>\n<ul>\n<li><code>Promise.all([p1, p2])</code> – виконується, коли всі Promise успішні (або одразу reject при першій помилці).</li>\n<li><code>Promise.race([p1, p2])</code> – повертає результат першого Promise, який виконався.</li>\n</ul>\n\n<h3>Мікротаски та макротаски</h3>\n<ul>\n<li>Обробники <code>then/catch/finally</code> потрапляють у <strong>мікротаски</strong> (виконуються раніше за <code>setTimeout</code>).</li>\n<li>Події <code>setTimeout / setInterval</code> – це <strong>макротаски</strong>.</li>\n<li>Тому <code>Promise.then()</code> завжди виконається перед таймаутами, навіть якщо вони мають час 0мс.</li>\n</ul>\n\n<h3>Приклад різниці</h3>\n<pre><code>console.log('Start');\n\nsetTimeout(() => console.log('Макротаска'), 0);\n\nPromise.resolve().then(() => console.log('Мікротаска'));\n\nconsole.log('End');\n\n// Порядок: Start → End → Мікротаска → Макротаска</code></pre>\n\n<p>✅ <strong>Мета:</strong> зрозуміти принцип роботи Promise, навчитися створювати та обробляти їх, використовувати <code>then/catch/finally</code>, писати ланцюжки асинхронних запитів і розуміти різницю між мікро- та макротасками.</p>\n\n<!-- Тема: Promise, fetch API -->",

    "lesson8": "<h2>Урок 8 – Інтеграція API Нової Пошти + Логін через Google</h2>\n<p>У цьому уроці ми розглянемо, як підключити API Нової Пошти для відправки/отримання даних про доставку, а також як реалізувати авторизацію користувача через Google.</p>\n\n<h3>Інтеграція Нової Пошти</h3>\n<ul>\n<li>API надає можливість відстежувати посилки, створювати накладні, отримувати список відділень.</li>\n<li>Використовуються <code>POST</code> та <code>GET</code> запити з ключем авторизації.</li>\n<li>Дані повертаються у форматі <code>JSON</code>.</li>\n</ul>\n\n<h3>Приклад запиту на відділення</h3>\n<pre><code>fetch('https://api.novaposhta.ua/v2.0/json/', {\n  method: 'POST',\n  headers: { 'Content-Type': 'application/json' },\n  body: JSON.stringify({\n    apiKey: 'YOUR_API_KEY',\n    modelName: 'AddressGeneral',\n    calledMethod: 'getWarehouses',\n    methodProperties: { CityName: 'Київ' }\n  })\n})\n.then(res => res.json())\n.then(data => console.log(data.data))\n.catch(err => console.error(err));</code></pre>\n\n<h3>Реєстрація та логін через Google</h3>\n<ul>\n<li>Застосовується <strong>OAuth 2.0</strong>.</li>\n<li>Користувач натискає кнопку «Увійти через Google».</li>\n<li>Відкривається вікно авторизації від Google, після чого програма отримує токен доступу.</li>\n<li>Дані користувача (ім’я, email, фото) можна зберігати у вашій базі.</li>\n</ul>\n\n<h3>Приклад підключення Google Login (JavaScript)</h3>\n<pre><code>// Підключення Google Identity Services SDK\nimport { google } from 'googleapis';\n\nfunction handleCredentialResponse(response) {\n  console.log('JWT Token:', response.credential);\n  // Розшифровка токена для отримання даних користувача\n}\n\nwindow.onload = function () {\n  google.accounts.id.initialize({\n    client_id: 'YOUR_GOOGLE_CLIENT_ID',\n    callback: handleCredentialResponse\n  });\n\n  google.accounts.id.renderButton(\n    document.getElementById('googleLogin'),\n    { theme: 'outline', size: 'large' }\n  );\n};</code></pre>\n\n<h3>Best practices</h3>\n<ul>\n<li>Ключ API Нової Пошти зберігайте у .env файлі, а не в коді.</li>\n<li>Використовуйте HTTPS для безпечної передачі даних.</li>\n<li>Для Google Login застосовуйте серверну валідацію токена (через Google API).</li>\n<li>Забезпечте fallback автентифікації (звичайний email+пароль) на випадок, якщо Google недоступний.</li>\n</ul>\n\n<p>✅ <strong>Мета:</strong> навчитися працювати з API сторонніх сервісів, інтегрувати доставку Нова Пошта в програму та реалізовувати безпечну автентифікацію користувачів через Google.</p>\n\n<!-- Технології: Нова Пошта API, OAuth 2.0, Google Identity Services -->",

    "lesson9": "<h2>Урок 9 – Перемикання теми (Dark / Light)</h2>\n<p>Сучасні інтерфейси часто підтримують кілька тем (світлу та темну). Це покращує UX та дозволяє користувачу налаштовувати вигляд сайту під свої вподобання.</p>\n\n<h3>Методи реалізації</h3>\n<ul>\n<li><strong>CSS клас</strong> – додаємо клас <code>.dark</code> або <code>.light</code> на <code>&lt;body&gt;</code> і змінюємо стилі.</li>\n<li><strong>CSS-перемінні</strong> – визначаємо кольори через <code>:root { --bg: #fff }</code> і змінюємо їх у темному режимі.</li>\n<li><strong>prefers-color-scheme</strong> – автоматичне визначення теми за налаштуваннями системи.</li>\n<li><strong>Збереження вибору</strong> – через LocalStorage, щоб пам’ятати останню тему.</li>\n</ul>\n\n<h3>CSS приклад</h3>\n<pre><code>:root {\n  --bg: #ffffff;\n  --text: #000000;\n}\n\n.dark-theme {\n  --bg: #121212;\n  --text: #ffffff;\n}\n\nbody {\n  background: var(--bg);\n  color: var(--text);\n}</code></pre>\n\n<h3>JS приклад</h3>\n<pre><code>const toggle = document.getElementById('themeToggle');\n\n// завантаження теми з LocalStorage\nif (localStorage.getItem('theme') === 'dark') {\n  document.body.classList.add('dark-theme');\n}\n\n// перемикання теми\n toggle.addEventListener('click', () => {\n  document.body.classList.toggle('dark-theme');\n  const theme = document.body.classList.contains('dark-theme') ? 'dark' : 'light';\n  localStorage.setItem('theme', theme);\n});</code></pre>\n\n<h3>Best practices</h3>\n<ul>\n<li>Використовуйте <code>prefers-color-scheme</code> для автоматичного визначення.</li>\n<li>Даєте користувачу можливість перемикати тему вручну.</li>\n<li>Зберігайте вибір у LocalStorage, щоб тема залишалась після перезавантаження.</li>\n<li>Перевіряйте контрастність тексту для доступності (WCAG).</li>\n</ul>\n\n<p>✅ <strong>Мета:</strong> навчитися реалізовувати перемикання теми, працювати з CSS-перемінними, LocalStorage та підтримувати системні налаштування користувача.</p>\n\n<!-- Технології: CSS variables, LocalStorage, prefers-color-scheme -->",

    "lesson10": "<h2>Урок 10-11 – Розробка сайту з додаванням товару в корзину</h2>\n<p>У цих уроках ми створимо базовий інтернет-магазин, де користувач може переглядати товари, додавати їх у корзину та зберігати дані про корзину.</p>\n\n<h3>1) HTML структура товарів</h3>\n<pre><code>&lt;div class=\"product\" data-id=\"1\" data-price=\"499\"&gt;\n  &lt;h3&gt;Товар 1&lt;/h3&gt;\n  &lt;p&gt;Ціна: 499 грн&lt;/p&gt;\n  &lt;button class=\"add-to-cart\"&gt;Додати в корзину&lt;/button&gt;\n&lt;/div&gt;\n&lt;div class=\"product\" data-id=\"2\" data-price=\"799\"&gt;\n  &lt;h3&gt;Товар 2&lt;/h3&gt;\n  &lt;p&gt;Ціна: 799 грн&lt;/p&gt;\n  &lt;button class=\"add-to-cart\"&gt;Додати в корзину&lt;/button&gt;\n&lt;/div&gt;\n&lt;div id=\"cart\"&gt;\n  &lt;h2&gt;Корзина&lt;/h2&gt;\n  &lt;ul id=\"cart-items\"&gt;&lt;/ul&gt;\n  &lt;p id=\"total\"&gt;Сума: 0&lt;/p&gt;\n&lt;/div&gt;\n</code></pre>\n\n<h3>2) JS логіка додавання в корзину</h3>\n<pre><code>const cart = [];\nconst cartItems = document.getElementById('cart-items');\nconst totalEl = document.getElementById('total');\n\nfunction updateCart() {\n  cartItems.innerHTML = '';\n  let total = 0;\n  cart.forEach(item =&gt; {\n    const li = document.createElement('li');\n    li.textContent = `${item.name} - ${item.price} грн x ${item.quantity}`;\n    cartItems.appendChild(li);\n    total += item.price * item.quantity;\n  });\n  totalEl.textContent = `Сума: ${total} грн`;\n  localStorage.setItem('cart', JSON.stringify(cart)); // зберігаємо корзину\n}\n\ndocument.querySelectorAll('.add-to-cart').forEach(button =&gt; {\n  button.addEventListener('click', (e) =&gt; {\n    const productEl = e.target.closest('.product');\n    const id = productEl.dataset.id;\n    const name = productEl.querySelector('h3').textContent;\n    const price = parseInt(productEl.dataset.price);\n    const existing = cart.find(item =&gt; item.id === id);\n    if (existing) {\n      existing.quantity++;\n    } else {\n      cart.push({ id, name, price, quantity: 1 });\n    }\n    updateCart();\n  });\n});\n\n// Завантаження корзини з LocalStorage при старті\nconst savedCart = JSON.parse(localStorage.getItem('cart'));\nif (savedCart) {\n  cart.push(...savedCart);\n  updateCart();\n}</code></pre>\n\n<h3>3) Додаткові можливості</h3>\n<ul>\n<li>Видалення товару з корзини.</li>\n<li>Зміна кількості через + / -.</li>\n<li>Збереження стану при перезавантаженні сторінки (LocalStorage або SessionStorage).</li>\n<li>Підсумкова сума та кількість товарів.</li>\n<li>Можна додати просту анімацію при додаванні товару (CSS transition / transform).</li>\n</ul>\n\n<h3>4) Best practices</h3>\n<ul>\n<li>Завжди перевіряйте LocalStorage перед використанням (null або неправильний формат).</li>\n<li>Окремий модуль/клас для роботи з корзиною допомагає підтримувати код чистим.</li>\n<li>Використовуйте id товару як унікальний ключ для ефективного оновлення кількості.</li>\n<li>Синхронізуйте дані корзини з сервером при логіні користувача.</li>\n<li>Підключайте відображення кількості товарів у шапці сайту (иконка корзини) для зручності UX.</li>\n</ul>\n\n<p>✅ <strong>Мета:</strong> навчитися створювати інтерактивний каталог товарів, додавати товари в корзину, зберігати стан через LocalStorage, оновлювати кількість та суму, а також підготувати основу для інтеграції з серверною частиною (API, авторизація).</p>\n\n<!-- Технології: JavaScript, LocalStorage, DOM -->",

    "lesson12": "<h2>Урок 12 – Початок роботи над фінальним проектом</h2>\n<p>У цьому уроці ми починаємо реалізацію фінального проекту: веб-сторінки кабінету користувача з модальними вікнами, зворотним зв'язком та слайдером. Сторінка повинна реалізовуватись відповідно до макету, включаючи шаблонну верстку для всіх елементів.</p>\n<p>Макет проекту доступний за посиланням: <a href=\"https://www.figma.com/design/S5OrQByO8RDHxSUm6XgHIF/Untitled?node-id=0-1&t=a2NviLmkAMLaRA3J-1\" target=\"_blank\">Figma макет</a></p>\n\n<h3>Цілі проекту</h3>\n<ul>\n<li>Реалізувати веб-сторінку згідно з макетом.</li>\n<li>Реалізувати модальні вікна з анімацією та формами.</li>\n<li>Реалізувати форму зворотного зв'язку з підтвердженням відправки.</li>\n<li>Реалізувати слайдер з навігаційними стрілками та індикаторами.</li>\n<li>Забезпечити шаблонну верстку всіх інших елементів сторінки.</li>\n</ul>\n\n<h3>Технічні вимоги</h3>\n<ul>\n<li>HTML5, CSS3, JavaScript для основного функціоналу.</li>\n<li>Можна використовувати бібліотеки JS (наприклад, jQuery) та CSS фреймворки (Bootstrap) при потребі.</li>\n<li>Сторінка повинна коректно відображатися в Chrome, Firefox, Safari, Edge.</li>\n</ul>\n\n<h3>Функціональні блоки</h3>\n<h4>Модальні вікна</h4>\n<ul>\n<li>Відображення по кліку на кнопки.</li>\n<li>Анімація появи/зникнення.</li>\n<li>Закриття кнопкою або кліком поза модальним вікном.</li>\n<li>Контент може містити текст, форми, зображення.</li>\n<li>Блокування взаємодії з основним контентом, поки вікно відкрите.</li>\n</ul>\n\n<h4>Зворотний зв'язок</h4>\n<ul>\n<li>Форма з полями: ім'я, email, тема, повідомлення.</li>\n<li>Кнопка \"Відправити\".</li>\n<li>Після відправки відображається повідомлення про успішну відправку.</li>\n</ul>\n\n<h4>Слайдер</h4>\n<ul>\n<li>Ручна навігація стрілками та кнопками.</li>\n<li>Індикатори поточного слайду.</li>\n<li>Адаптивність для різних розмірів екранів.</li>\n</ul>\n\n<h4>Шаблонна верстка</h4>\n<ul>\n<li>Реалізація всіх інших елементів згідно з макетом.</li>\n<li>CSS стилізація та адаптивність.</li>\n<li>Тестування на різних пристроях та браузерах.</li>\n</ul>\n\n<p>✅ <strong>Мета:</strong> навчитися організовувати роботу над проектом, інтегрувати всі функціональні блоки (модальні вікна, зворотний зв'язок, слайдер) та реалізувати сторінку відповідно до макету, використовуючи сучасні веб-технології.</p>\n\n<!-- Технології: HTML5, CSS3, JavaScript, Figma макет, jQuery / Bootstrap за потреби -->",

    "lesson13": "<h2>Урок 13 – Встановлення NodeJS та вступ до React</h2>\n<p>У цьому уроці ми розглянемо, як встановити Node.js та npm, а також дамо перше знайомство з React — популярною бібліотекою для створення інтерфейсів.</p>\n\n<h3>1. Що таке Node.js</h3>\n<ul>\n<li>Node.js – це середовище виконання JavaScript на сервері.</li>\n<li>Дозволяє запускати JS поза браузером.</li>\n<li>Має власний пакетний менеджер <code>npm</code> для встановлення бібліотек.</li>\n<li>Необхідний для розробки сучасних фронтенд-проектів, включно з React.</li>\n</ul>\n\n<h3>2. Встановлення Node.js</h3>\n<ul>\n<li>Зайдіть на офіційний сайт Node.js: <code>nodejs.org</code>.</li>\n<li>Виберіть LTS версію та завантажте інсталятор для вашої ОС.</li>\n<li>Після інсталяції перевірте версію у терміналі:</li>\n</ul>\n<pre><code>node -v\nnpm -v</code></pre>\n\n<h3>3. Що таке React</h3>\n<ul>\n<li>React – це JavaScript бібліотека для створення користувацьких інтерфейсів.</li>\n<li>Основна ідея – компоненти: невеликі шматки UI, які можна повторно використовувати.</li>\n<li>React дозволяє створювати динамічні сторінки, працюючи з віртуальним DOM для швидкого оновлення.</li>\n<li>React може працювати з різними бекенд-серверами, REST API або GraphQL.</li>\n</ul>\n\n<h3>4. Створення першого React проекту</h3>\n<ul>\n<li>За допомогою Create React App:</li>\n<pre><code>npx create-react-app my-app\ncd my-app\nnpm start</code></pre>\n<li>Після цього відкриється локальний сервер, зазвичай <code>http://localhost:3000</code>.</li>\n<li>Структура проекту: <code>src/</code> для компонентів, <code>public/</code> для статичних файлів.</li>\n</ul>\n\n<h3>5. Перший React компонент</h3>\n<pre><code>function App() {\n  return (\n    &lt;div&gt;\n      &lt;h1&gt;Привіт, React!&lt;/h1&gt;\n    &lt;/div&gt;\n  );\n}\n\nexport default App;</code></pre>\n\n<h3>6. Важливі поняття</h3>\n<ul>\n<li>JSX – синтаксис React для написання HTML в JS.</li>\n<li>Компоненти – функції або класи, які повертають UI.</li>\n<li>Props – властивості для передачі даних у компоненти.</li>\n<li>State – внутрішній стан компоненту, який може змінюватися динамічно.</li>\n</ul>\n\n<p>✅ <strong>Мета:</strong> встановити Node.js та npm, зрозуміти основи React, створити перший компонент і запустити локальний сервер для розробки.</p>\n\n<!-- Технології: Node.js, npm, React, Create React App -->",

    "lesson14": "<h2>Урок 14 – React компоненти та useState</h2>\n<p>У цьому уроці ми розглянемо, як створювати компоненти у React та використовувати хук <code>useState</code> для керування станом компонентів.</p>\n\n<h3>1. Компоненти React</h3>\n<ul>\n<li>Компонент – це функція або клас, який повертає JSX (HTML-подібний синтаксис у JS).</li>\n<li>Вони дозволяють створювати повторно використовувані частини інтерфейсу.</li>\n<li>Приклад функціонального компоненту:</li>\n</ul>\n<pre><code>function Header() {\n  return &lt;h1&gt;Привіт, React!&lt;/h1&gt;;\n}\n\nexport default Header;</code></pre>\n\n<h3>2. Props – передача даних у компоненти</h3>\n<pre><code>function Product(props) {\n  return &lt;div&gt;Назва: {props.name} - Ціна: {props.price}&lt;/div&gt;;\n}\n\n// Використання\n&lt;Product name=\"Товар 1\" price={499} /&gt;</code></pre>\n\n<h3>3. useState – керування станом</h3>\n<ul>\n<li>useState дозволяє зберігати внутрішній стан компоненту.</li>\n<li>Повертає масив з поточного стану та функції для його оновлення.</li>\n<li>При зміні стану React автоматично рендерить компонент заново.</li>\n</ul>\n\n<h3>Приклад лічильника:</h3>\n<pre><code>import React, { useState } from 'react';\n\nfunction Counter() {\n  const [count, setCount] = useState(0);\n\n  return (\n    &lt;div&gt;\n      &lt;p&gt;Кількість: {count}&lt;/p&gt;\n      &lt;button onClick={() =&gt; setCount(count + 1)}&gt;Додати&lt;/button&gt;\n      &lt;button onClick={() =&gt; setCount(count - 1)}&gt;Відняти&lt;/button&gt;\n    &lt;/div&gt;\n  );\n}\n\nexport default Counter;</code></pre>\n\n<h3>4. Використання кількох станів</h3>\n<pre><code>function Form() {\n  const [name, setName] = useState('');\n  const [email, setEmail] = useState('');\n\n  return (\n    &lt;form&gt;\n      &lt;input value={name} onChange={e =&gt; setName(e.target.value)} placeholder=\"Ім'я\" /&gt;\n      &lt;input value={email} onChange={e =&gt; setEmail(e.target.value)} placeholder=\"Email\" /&gt;\n    &lt;/form&gt;\n  );\n}</code></pre>\n\n<h3>5. Best practices</h3>\n<ul>\n<li>Використовуйте маленькі, повторно використовувані компоненти.</li>\n<li>Стан повинен бути локальним для компонента, який його використовує.</li>\n<li>Для складних станів можна використовувати useReducer або глобальні стейт-менеджери.</li>\n<li>Назви станів та функцій оновлення повинні бути зрозумілими.</li>\n</ul>\n\n<p>✅ <strong>Мета:</strong> навчитися створювати функціональні компоненти, передавати дані через props та керувати станом за допомогою useState, що є основою для динамічного UI у React.</p>\n\n<!-- Технології: React, JSX, useState -->",

    "lesson15": "<h2>Урок 15 – React Router</h2>\n<p>У цьому уроці ми розглянемо, як організувати маршрутизацію у React за допомогою бібліотеки <code>react-router-dom</code>, щоб створювати багатосторінкові додатки без перезавантаження сторінки.</p>\n\n<h3>1. Встановлення React Router</h3>\n<pre><code>npm install react-router-dom</code></pre>\n\n<h3>2. Основні компоненти React Router</h3>\n<ul>\n<li><code>BrowserRouter</code> – обгортка для всіх маршрутов, яка використовує історію браузера.</li>\n<li><code>Routes</code> – контейнер для списку маршрутов.</li>\n<li><code>Route</code> – визначає шлях і компонент, який рендериться на цьому шляху.</li>\n<li><code>Link</code> – навігаційна посилання без перезавантаження сторінки.</li>\n</ul>\n\n<h3>3. Приклад базової маршрутизації</h3>\n<pre><code>import { BrowserRouter, Routes, Route, Link } from 'react-router-dom';\nimport Home from './Home';\nimport About from './About';\n\nfunction App() {\n  return (\n    &lt;BrowserRouter&gt;\n      &lt;nav&gt;\n        &lt;Link to=\"/\"&gt;Головна&lt;/Link&gt; | \n        &lt;Link to=\"/about\"&gt;Про нас&lt;/Link&gt;\n      &lt;/nav&gt;\n      &lt;Routes&gt;\n        &lt;Route path=\"/\" element={&lt;Home /&gt;} /&gt;\n        &lt;Route path=\"/about\" element={&lt;About /&gt;} /&gt;\n      &lt;/Routes&gt;\n    &lt;/BrowserRouter&gt;\n  );\n}\n\nexport default App;</code></pre>\n\n<h3>4. Динамічні маршрути</h3>\n<pre><code>import { useParams } from 'react-router-dom';\n\nfunction ProductPage() {\n  const { id } = useParams();\n  return &lt;div&gt;Сторінка товару з ID: {id}&lt;/div&gt;;\n}\n\n// Використання: &lt;Route path=\"/product/:id\" element={&lt;ProductPage /&gt;} /&gt;</code></pre>\n\n<h3>5. Навігація програмно</h3>\n<pre><code>import { useNavigate } from 'react-router-dom';\n\nfunction Home() {\n  const navigate = useNavigate();\n  return &lt;button onClick={() =&gt; navigate('/about')}&gt;Перейти на About&lt;/button&gt;;\n}</code></pre>\n\n<h3>6. Best practices</h3>\n<ul>\n<li>Використовуйте семантичні посилання через <code>Link</code> замість <code>&lt;a&gt;</code>.</li>\n<li>Динамічні маршрути робіть через <code>useParams</code>.</li>\n<li>Програмну навігацію робіть через <code>useNavigate</code>.</li>\n<li>Організовуйте маршрути у окремому файлі для чистоти коду.</li>\n<li>Для складних проектів можна використовувати <code>Outlet</code> для вкладених маршрутів.</li>\n</ul>\n\n<p>✅ <strong>Мета:</strong> навчитися створювати багатосторінкові React-додатки, організовувати маршрути, використовувати динамічні маршрути та програмну навігацію для зручності користувача.</p>\n\n<!-- Технології: React, react-router-dom, BrowserRouter, Route, Routes, Link, useNavigate, useParams -->",

    "lesson16": "<h2>Урок 16 – Презентація фінального проекту</h2>\n<p>Цей урок присвячений демонстрації вашого фінального проекту та повторенню всіх матеріалів курсу.</p>\n\n<h3>1. Презентація фінального проекту</h3>\n<ul>\n<li>Ви будете презентувати свій веб-додаток кабінету користувача, який реалізований відповідно до макету.</li>\n<li>Перевірятиметься робота всіх функціональних блоків:</li>\n  <ul>\n    <li>Модальні вікна з формами та анімацією.</li>\n    <li>Форма зворотного зв’язку з підтвердженням відправки.</li>\n    <li>Слайдер з навігаційними стрілками та індикаторами.</li>\n    <li>Шаблонна та адаптивна верстка сторінки.</li>\n  </ul>\n<li>Важливо показати, як ваш код організований: компоненти React, використання useState, маршрутизація через React Router.</li>\n</ul>\n\n<h3>2. Перевірка коду</h3>\n<ul>\n<li>Інструктор або ви самостійно будете дивитись код вашого проекту.</li>\n<li>Перевірятиметься:</li>\n  <ul>\n    <li>Чистота та структурованість коду.</li>\n    <li>Правильне використання компонентів та хуків React.</li>\n    <li>Коректна робота функціональних елементів (кнопки, форми, слайдер).</li>\n    <li>Стан (state) та props використані правильно і ефективно.</li>\n  </ul>\n</ul>\n\n<h3>3. Повторення теорії курсу</h3>\n<ul>\n<li>Будете проходити всі ключові теми:</li>\n  <ul>\n    <li>Декоратори та оптимізація коду (lesson 1).</li>\n    <li>Git та GitHub, робота як колаборатор (lesson 2).</li>\n    <li>Slider та Git (lesson 3).</li>\n    <li>Мультиязичність (lesson 4).</li>\n    <li>Валідація форми (lesson 5).</li>\n    <li>AJAX, JSON, HTTP, DNS, асинхронний код, мікро- та макротаски (lesson 6).</li>\n    <li>Promise (lesson 7).</li>\n    <li>Інтеграція нової пошти та авторизація через Google (lesson 8).</li>\n    <li>Перемикання теми сайту (lesson 9).</li>\n    <li>Додавання товару у корзину (lesson 10-11).</li>\n    <li>Початок фінального проекту: модальні вікна, слайдер, шаблонна верстка (lesson 12).</li>\n    <li>NodeJS та React (lesson 13).</li>\n    <li>React компоненти та useState (lesson 14).</li>\n    <li>React Router (lesson 15).</li>\n  </ul>\n</ul>\n\n<h3>4. Мета уроку</h3>\n<ul>\n<li>Продемонструвати готовий фінальний проект.</li>\n<li>Перевірити знання та навички за всіма темами курсу.</li>\n<li>Отримати фідбек щодо організації коду та функціоналу проекту.</li>\n<li>Підготуватися до самостійної розробки складних проектів у майбутньому.</li>\n</ul>\n\n<p>✅ <strong>Мета:</strong> узагальнити всі знання, перевірити код, оцінити функціональні можливості фінального проекту та закріпити практичні навички.</p>\n\n<!-- Технології: HTML5, CSS3, JavaScript, React, useState, React Router, Git, AJAX, LocalStorage, Figma макет -->"
};
const lessonsContainer = document.getElementById("lessons-grid");
const viewer = document.getElementById("lesson-viewer");
const viewerTitle = document.getElementById("viewer-title");
const viewerText = document.getElementById("viewer-text");
const backBtn = document.getElementById("back-btn");

Object.keys(lessonsContent).forEach(lessonId => {
    const fileDiv = document.createElement("div");
    fileDiv.className = "file";
    fileDiv.dataset.id = lessonId;

    const tempDiv = document.createElement("div");
    tempDiv.innerHTML = lessonsContent[lessonId];
    const title = tempDiv.querySelector("h2")?.textContent || lessonId;

    fileDiv.textContent = `📄 ${title}`;
    lessonsContainer.appendChild(fileDiv);

    fileDiv.addEventListener("click", () => {
        viewerTitle.textContent = title;
        viewerText.innerHTML = lessonsContent[lessonId];
        lessonsContainer.classList.add("hidden");
        viewer.classList.remove("hidden");
    });
});

backBtn.addEventListener("click", () => {
    viewer.classList.add("hidden");
    lessonsContainer.classList.remove("hidden");
});