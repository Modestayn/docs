const lessonContainer = document.getElementById("lesson-container");
const lessonsGrid = document.getElementById("lessons-grid");
const lessonsContent = {
    "lesson1": "<h2>Урок 1 – TypeScript: Повне занурення у типізацію та архітектуру</h2><p>TypeScript — це мова, що розширює JavaScript, додаючи статичну типізацію, підтримку ООП, інтерфейси, generics і покращені інструменти для масштабованих проєктів. Його мета — зробити код безпечнішим, зрозумілішим і передбачуваним.</p><h3>Основні концепції:</h3><ul><li><strong>Базові типи:</strong> string, number, boolean, null, undefined, any, unknown, void, never.</li><li><strong>Складні типи:</strong> масиви, об’єкти, функції, кортежі (tuples) — <code>const user: [string, number] = ['Artem', 22]</code>.</li><li><strong>Union та Intersection типи:</strong> <code>type Result = string | number</code>, <code>type Extended = A & B</code>.</li><li><strong>Type Aliases та Interfaces:</strong> гнучкі інструменти опису структури даних. Інтерфейси можна розширювати, типи — комбінувати.</li><li><strong>Generics:</strong> параметризація типів для універсальних функцій та класів — <code>function identity&lt;T&gt;(arg: T): T { return arg }</code>.</li><li><strong>Generic Constraints:</strong> <code>&lt;T extends object&gt;</code>, <code>&lt;T extends keyof U&gt;</code> — обмеження для контролю типів.</li><li><strong>Utility Types:</strong> Partial, Required, Pick, Omit, Exclude, Extract, Record, ReturnType, Readonly, NonNullable — готові для маніпуляцій типами.</li><li><strong>Type Guards:</strong> перевірка типів у рантаймі — <code>typeof</code>, <code>instanceof</code>, <code>in</code> та користувацькі функції типу <code>isUser(value): value is User</code>.</li><li><strong>Enum-и:</strong> зручні для констант — <code>enum Role { Admin, User, Guest }</code>.</li><li><strong>Класи:</strong> модифікатори <code>public</code>, <code>private</code>, <code>protected</code>, <code>readonly</code>, абстрактні класи, наслідування.</li><li><strong>Namespaces та Modules:</strong> поділ коду для підтримки великої архітектури.</li><li><strong>Keyof, Indexed Access, Conditional Types:</strong> <code>keyof T</code>, <code>T[K]</code>, <code>T extends U ? X : Y</code>, <code>infer</code> — просунуті інструменти типізації.</li></ul><h3>Приклад:</h3><pre><code>interface User { id: number; name: string; role?: 'admin' | 'user'; }\n\ntype ApiResponse&lt;T&gt; = { success: boolean; data: T };\n\nfunction fetchUser&lt;T extends User&gt;(user: T): ApiResponse&lt;T&gt; {\n    console.log(`Отримано користувача: ${user.name}`);\n    return { success: true, data: user };\n}\n\nconst artem = { id: 1, name: 'Артем', role: 'admin' };\nconst result = fetchUser(artem);\nconsole.log(result.data.name);\n\n// Utility типи\ninterface Post { title: string; views: number; }\nconst draft: Partial&lt;Post&gt; = { title: 'Нова стаття' };\n\ntype RoleNames = keyof typeof Role; // 'Admin' | 'User' | 'Guest'</code></pre><p>✅ <strong>Мета:</strong> студенти повинні навчитися:</p><ul><li>Використовувати всі основні та просунуті типи.</li><li>Створювати гнучкі generics з обмеженнями.</li><li>Розуміти різницю між type, interface, enum та class.</li><li>Застосовувати conditional, mapped та utility типи.</li><li>Оптимізувати великі проєкти через типізацію, модулі та архітектуру коду.</li></ul><!-- TS Deep Dive: типи, generics, keyof, infer, utility, OOP -->",

    "lesson2": "<h2>Урок 2 – Базові React Hooks: useState, useEffect, useRef</h2><p>Hooks — це спеціальні функції в React, які дозволяють використовувати стан, життєвий цикл і доступ до DOM без класів. Вони спрощують логіку та роблять компоненти чистими й гнучкими.</p><h3>Основні хуки:</h3><ul><li><strong>useState</strong> — створює локальний стан у функціональному компоненті.</li><li><strong>useEffect</strong> — виконує побічні ефекти (запити, підписки, оновлення заголовка).</li><li><strong>useRef</strong> — зберігає мутабельне значення між рендерами, дає доступ до DOM-елемента.</li><li><strong>useMemo</strong> та <strong>useCallback</strong> (попередній перегляд) — оптимізація продуктивності та запобігання непотрібним рендерам.</li></ul><h3>Приклад:</h3><pre><code>import { useState, useEffect, useRef } from 'react';\n\nfunction Counter() {\n  const [count, setCount] = useState(0);\n  const renders = useRef(0);\n\n  useEffect(() => {\n    renders.current++;\n    document.title = `Клікнули ${count} разів`;\n  }, [count]);\n\n  return (\n    <div>\n      <p>Кількість кліків: {count}</p>\n      <p>Ререндерів: {renders.current}</p>\n      <button onClick={() => setCount(count + 1)}>+</button>\n    </div>\n  );\n}</code></pre><p>✅ <strong>Мета:</strong> студенти повинні навчитися:</p><ul><li>Керувати станом компонентів через <code>useState</code>.</li><li>Розуміти життєвий цикл компонентів через <code>useEffect</code>.</li><li>Працювати з <code>useRef</code> для DOM та збереження значень між рендерами.</li><li>Будувати чисту логіку без класів, розуміти rerender flow.</li></ul><!-- React Hooks Basics: useState, useEffect, useRef -->",

    "lesson3": "<h2>Урок 3 – Просунуті React Hooks: useMemo, useCallback, useContext, useReducer, Custom Hooks</h2><p>Просунуті хуки дозволяють контролювати продуктивність, створювати гнучку архітектуру стану та повторно використовувати логіку між компонентами. Вони розкривають справжню силу React.</p><h3>Основні концепції:</h3><ul><li><strong>useMemo</strong> — мемоізує обчислення, щоб уникати зайвих перерахунків.</li><li><strong>useCallback</strong> — мемоізує функції, щоб не створювати нові при кожному рендері.</li><li><strong>useContext</strong> — дозволяє передавати дані через дерево компонентів без props.</li><li><strong>useReducer</strong> — альтернатива useState для складної логіки зміни стану.</li><li><strong>Custom Hooks</strong> — створення власних хуків для повторного використання логіки (імена завжди починаються з <code>use</code>).</li></ul><h3>Приклад:</h3><pre><code>import { useState, useMemo, useCallback, useReducer, useContext, createContext } from 'react';\n\n// Context приклад\nconst ThemeContext = createContext('light');\n\n// Reducer приклад\nfunction reducer(state, action) {\n  switch (action.type) {\n    case 'inc': return { count: state.count + 1 };\n    case 'dec': return { count: state.count - 1 };\n    default: return state;\n  }\n}\n\nfunction AdvancedHooks() {\n  const [state, dispatch] = useReducer(reducer, { count: 0 });\n  const [theme, setTheme] = useState('light');\n\n  const expensiveValue = useMemo(() => state.count * 10, [state.count]);\n  const toggleTheme = useCallback(() => setTheme(prev => prev === 'light' ? 'dark' : 'light'), []);\n\n  return (\n    <ThemeContext.Provider value={theme}>\n      <div style={{ background: theme === 'light' ? '#fff' : '#222', color: theme === 'light' ? '#000' : '#fff' }}>\n        <p>Лічильник: {state.count}</p>\n        <p>Мемоізоване значення: {expensiveValue}</p>\n        <button onClick={() => dispatch({ type: 'inc' })}>+</button>\n        <button onClick={() => dispatch({ type: 'dec' })}>-</button>\n        <button onClick={toggleTheme}>Змінити тему</button>\n      </div>\n    </ThemeContext.Provider>\n  );\n}\n\n// Custom Hook приклад\nfunction useWindowWidth() {\n  const [width, setWidth] = useState(window.innerWidth);\n  useEffect(() => {\n    const handleResize = () => setWidth(window.innerWidth);\n    window.addEventListener('resize', handleResize);\n    return () => window.removeEventListener('resize', handleResize);\n  }, []);\n  return width;\n}</code></pre><p>✅ <strong>Мета:</strong> студенти повинні навчитися:</p><ul><li>Оптимізувати продуктивність через <code>useMemo</code> та <code>useCallback</code>.</li><li>Використовувати <code>useContext</code> для глобального стану без props drilling.</li><li>Керувати складним станом через <code>useReducer</code>.</li><li>Створювати власні Custom Hooks для повторного використання логіки.</li><li>Розуміти, як хуки взаємодіють і впливають на життєвий цикл компонентів.</li></ul><!-- Advanced React Hooks: useMemo, useCallback, useContext, useReducer, custom hooks -->",

    "lesson4": "<h2>Урок 4 – useContext та useReducer: глобальний стан без Redux</h2><p>Хуки <code>useContext</code> і <code>useReducer</code> дозволяють будувати потужну систему керування станом без зовнішніх бібліотек. Вони дають змогу створити власний легкий аналог Redux прямо у React.</p><h3>Основні концепції:</h3><ul><li><strong>useContext</strong> — забезпечує доступ до спільного стану між компонентами без передачі props.</li><li><strong>createContext</strong> — створює контекст (глобальне сховище).</li><li><strong>useReducer</strong> — керує станом через редьюсер (функцію, що змінює стан на основі дії).</li><li><strong>Context + Reducer</strong> = архітектура з єдиним джерелом правди (як у Redux).</li></ul><h3>Приклад:</h3><pre><code>import { createContext, useContext, useReducer } from 'react';\n\n// 1. Створюємо контекст\nconst CounterContext = createContext(null);\n\n// 2. Редʼюсер функція\nfunction counterReducer(state, action) {\n  switch (action.type) {\n    case 'increment': return { count: state.count + 1 };\n    case 'decrement': return { count: state.count - 1 };\n    default: return state;\n  }\n}\n\n// 3. Провайдер глобального стану\nexport function CounterProvider({ children }) {\n  const [state, dispatch] = useReducer(counterReducer, { count: 0 });\n  return (\n    <CounterContext.Provider value={{ state, dispatch }}>\n      {children}\n    </CounterContext.Provider>\n  );\n}\n\n// 4. Хук для використання контексту\nexport function useCounter() {\n  return useContext(CounterContext);\n}\n\n// 5. Компонент приклад\nfunction Counter() {\n  const { state, dispatch } = useCounter();\n  return (\n    <div>\n      <h3>Лічильник: {state.count}</h3>\n      <button onClick={() => dispatch({ type: 'increment' })}>+</button>\n      <button onClick={() => dispatch({ type: 'decrement' })}>-</button>\n    </div>\n  );\n}</code></pre><p>✅ <strong>Мета:</strong> студенти повинні навчитися:</p><ul><li>Розуміти архітектуру контексту React та коли її використовувати.</li><li>Створювати глобальний стан за допомогою <code>useContext</code> та <code>useReducer</code>.</li><li>Відокремлювати бізнес-логіку від UI.</li><li>Організовувати чисту архітектуру компонентів без Redux.</li><li>Будувати власні провайдери та кастомні хуки для глобального стану.</li></ul><!-- React useContext + useReducer: глобальний стан, архітектура, контекст, редьюсер -->",

    "lesson5": "<h2>Урок 5 – Props у React: передача даних між компонентами</h2><p>Props (від <em>properties</em>) — це механізм передачі даних від батьківського компонента до дочірнього. Вони дозволяють створювати динамічні, багаторазові та гнучкі компоненти, які змінюються залежно від контексту використання.</p><h3>Основні концепції:</h3><ul><li><strong>Передача даних:</strong> props дозволяють передавати текст, числа, функції, масиви, обʼєкти або JSX.</li><li><strong>Імм'ютабельність:</strong> props не можна змінювати всередині дочірнього компонента.</li><li><strong>Деструктуризація:</strong> зручний спосіб отримати props без префіксу <code>props.</code>.</li><li><strong>Props.children:</strong> спеціальний проп для передачі вкладеного контенту.</li><li><strong>Default props:</strong> значення за замовчуванням для відсутніх параметрів.</li><li><strong>Типізація:</strong> через PropTypes або TypeScript (інтерфейси).</li></ul><h3>Приклад:</h3><pre><code>import React from 'react';\n\n// Компонент з деструктуризацією props\nfunction UserCard({ name, age, online, children }) {\n  return (\n    <div style={{ border: '1px solid #ccc', padding: '10px', margin: '10px' }}>\n      <h3>{name}</h3>\n      <p>Вік: {age}</p>\n      <p>Статус: {online ? '🟢 Онлайн' : '🔴 Офлайн'}</p>\n      <div>{children}</div>\n    </div>\n  );\n}\n\n// Використання компоненту\nexport default function App() {\n  return (\n    <div>\n      <UserCard name=\"Артем\" age={22} online={true}>\n        <button>Написати</button>\n      </UserCard>\n      <UserCard name=\"Оля\" age={20} online={false}>\n        <em>Офлайн користувач</em>\n      </UserCard>\n    </div>\n  );\n}</code></pre><p>✅ <strong>Мета:</strong> студенти повинні навчитися:</p><ul><li>Передавати дані між компонентами за допомогою props.</li><li>Розуміти принцип «односпрямованого потоку даних» у React.</li><li>Використовувати деструктуризацію та <code>props.children</code>.</li><li>Задавати типи props для підвищення надійності коду.</li><li>Будувати гнучкі, повторно використовувані компоненти.</li></ul><!-- React Props: передача даних, деструктуризація, children, типізація -->",

    "lesson6": "<h2>Урок 6 – Підсумковий тест: TypeScript, React Hooks, Context та Props</h2><p>Цей тест допоможе перевірити розуміння ключових тем курсу: типізація у TypeScript, робота з хуками React, контекстом, пропсами та оптимізацією ререндерів. Відповідай письмово або практично — у коді.</p><h3>Теоретичні запитання:</h3><ol><li><strong>Основи TypeScript</strong><ul><li>Що таке <code>type</code> і чим він відрізняється від <code>interface</code>?</li><li>Як типізувати масив рядків у TypeScript?</li><li>Як зробити властивість обов’язковою або необов’язковою в інтерфейсі?</li></ul></li><li><strong>Базові хуки</strong><ul><li>Для чого використовується хук <code>useState</code>?</li><li>Що таке <code>useEffect</code> і коли він виконується?</li><li>Що буде, якщо не вказати масив залежностей у <code>useEffect</code>?</li></ul></li><li><strong>Просунуті хуки</strong><ul><li>Для чого використовується <code>useMemo</code>?</li><li>У чому різниця між <code>useCallback</code> і <code>useMemo</code>?</li><li>Як працює <code>useRef</code> і для чого він може бути корисним?</li></ul></li><li><strong>Context та ререндери</strong><ul><li>Як створити і використати контекст за допомогою <code>useContext</code>?</li><li>Який підхід допомагає зменшити кількість непотрібних ререндерів у компоненті?</li><li>Коли краще використати <code>useMemo</code>, а коли <code>React.memo</code>?</li></ul></li><li><strong>Props</strong><ul><li>Як типізувати пропси у функціональному компоненті?</li><li>Як передати функцію у дочірній компонент і правильно її типізувати?</li><li>Чим відрізняється <code>children</code> від звичайного пропса?</li></ul></li></ol><h3>Практичні завдання:</h3><ol><li><strong>Завдання 1:</strong> Створи тип <code>User</code> з такими полями:<ul><li><code>id</code>: число</li><li><code>name</code>: рядок</li><li><code>email</code>: рядок</li><li><code>isAdmin?</code>: необов’язкове булеве поле</li></ul></li><li><strong>Завдання 2:</strong> Зроби компонент <code>Counter</code>, який:<ul><li>показує лічильник;</li><li>збільшує його при кліку;</li><li>виводить у <code>console.log</code> нове значення при кожній зміні.</li></ul></li><li><strong>Завдання 3:</strong> Зроби компонент <code>ExpensiveCalculation</code>, який:<ul><li>приймає <code>count</code> як пропс;</li><li>рахує \"важку\" функцію (наприклад, фібоначчі);</li><li>використовує <code>useMemo</code>, щоб не рахувати при кожному рендері.</li></ul></li><li><strong>Завдання 4:</strong> Створи контекст теми (<code>ThemeContext</code>) зі значенням <code>'light' | 'dark'</code>:<ul><li>В одному компоненті покажи тему;</li><li>В іншому — кнопку для зміни теми;</li><li>⭐ Додатково: мемоізуй дочірній компонент, щоб не ререндерився зайвий раз.</li></ul></li></ol><p>✅ <strong>Мета:</strong> студенти повинні продемонструвати:</p><ul><li>Розуміння типізації у TypeScript.</li><li>Володіння базовими та просунутими React Hooks.</li><li>Уміння працювати з контекстом і оптимізовувати ререндери.</li><li>Коректну передачу та типізацію пропсів.</li><li>Практичне застосування знань у невеликих компонентах.</li></ul><!-- React + TS Final Test -->",

    "lesson7": "<h2>Урок 7 – RTK (Redux Toolkit) + React Router DOM</h2>\n<p>У цьому уроці розглянемо, як правильно поєднати <strong>Redux Toolkit</strong> для управління станом і <strong>React Router DOM</strong> для маршрутизації. Це основа побудови масштабованих React-застосунків.</p>\n\n<h3>Redux Toolkit – основи:</h3>\n<ul>\n<li>Створення <code>slice</code> з <code>createSlice()</code>.</li>\n<li>Використання <code>configureStore()</code> для збирання store.</li>\n<li>Підключення store через <code>&lt;Provider&gt;</code>.</li>\n<li>Отримання даних з <code>useSelector()</code> та виклики екшенів через <code>useDispatch()</code>.</li>\n<li>Асинхронні операції за допомогою <code>createAsyncThunk()</code>.</li>\n</ul>\n\n<h3>React Router DOM – навігація:</h3>\n<ul>\n<li>Налаштування маршрутизації з <code>createBrowserRouter</code> або <code>&lt;BrowserRouter&gt;</code>.</li>\n<li>Використання <code>&lt;Routes&gt;</code> та <code>&lt;Route&gt;</code> для структури сторінок.</li>\n<li>Перехід між сторінками за допомогою <code>useNavigate()</code> або <code>&lt;Link&gt;</code>.</li>\n<li>Параметри маршруту: <code>useParams()</code>.</li>\n<li>Захищені маршрути через умовний рендеринг або кастомний компонент <code>ProtectedRoute</code>.</li>\n</ul>\n\n<h3>Приклад:</h3>\n<pre><code>// store.js\nimport { configureStore, createSlice } from '@reduxjs/toolkit'\n\nconst counterSlice = createSlice({\n  name: 'counter',\n  initialState: { value: 0 },\n  reducers: {\n    increment: (state) => { state.value += 1 },\n    decrement: (state) => { state.value -= 1 }\n  }\n})\n\nexport const { increment, decrement } = counterSlice.actions\nexport const store = configureStore({ reducer: { counter: counterSlice.reducer } })\n\n// App.jsx\nimport { Provider, useSelector, useDispatch } from 'react-redux'\nimport { BrowserRouter, Routes, Route, Link } from 'react-router-dom'\nimport { store, increment } from './store'\n\nfunction Home() {\n  const value = useSelector(s => s.counter.value)\n  const dispatch = useDispatch()\n  return &lt;div&gt;&lt;h2&gt;Home: {value}&lt;/h2&gt;&lt;button onClick={() =&gt; dispatch(increment())}&gt;+&lt;/button&gt;&lt;/div&gt;\n}\n\nfunction About() { return &lt;h2&gt;About Page&lt;/h2&gt; }\n\nexport default function App() {\n  return (\n    &lt;Provider store={store}&gt;\n      &lt;BrowserRouter&gt;\n        &lt;nav&gt;&lt;Link to='/'&gt;Home&lt;/Link&gt; | &lt;Link to='/about'&gt;About&lt;/Link&gt;&lt;/nav&gt;\n        &lt;Routes&gt;\n          &lt;Route path='/' element={&lt;Home /&gt;} /&gt;\n          &lt;Route path='/about' element={&lt;About /&gt;} /&gt;\n        &lt;/Routes&gt;\n      &lt;/BrowserRouter&gt;\n    &lt;/Provider&gt;\n  )\n}</code></pre>\n\n<p>✅ <strong>Мета:</strong> студенти повинні навчитися:</p>\n<ul>\n<li>Налаштовувати Redux Toolkit у проєкті React.</li>\n<li>Писати slice-и, редюсери й асинхронні thunk-и.</li>\n<li>Працювати з React Router DOM для створення SPA.</li>\n<li>Інтегрувати маршрути з глобальним станом (наприклад, авторизація).</li>\n<li>Організовувати архітектуру з Redux + Router для масштабованості.</li>\n</ul>",

    "lesson8": "<h2>Урок 8 – Axios: робота з HTTP-запитами у React</h2><p>Axios — популярна бібліотека для виконання HTTP-запитів у React та інших JavaScript-проєктах. Вона спрощує роботу з API, підтримує проміси, перехоплювачі (interceptors) та налаштування заголовків.</p><h3>Основні концепції:</h3><ul><li>Виконання GET, POST, PUT, DELETE-запитів.</li><li>Обробка промісів через <code>.then/.catch</code> або <code>async/await</code>.</li><li>Налаштування заголовків, токенів та параметрів запиту.</li><li>Перехоплювачі (<code>interceptors</code>) для обробки помилок або авторизації.</li><li>Обʼєднання кількох запитів через <code>axios.all()</code>.</li></ul><h3>Приклад:</h3><pre><code>import axios from 'axios';\nimport { useState, useEffect } from 'react';\n\nfunction UsersList() {\n  const [users, setUsers] = useState([]);\n  const [loading, setLoading] = useState(true);\n\n  useEffect(() =&gt; {\n    const fetchUsers = async () =&gt; {\n      try {\n        const response = await axios.get('https://jsonplaceholder.typicode.com/users');\n        setUsers(response.data);\n      } catch (error) {\n        console.error('Помилка запиту:', error);\n      } finally {\n        setLoading(false);\n      }\n    };\n    fetchUsers();\n  }, []);\n\n  if (loading) return &lt;p&gt;Завантаження...&lt;/p&gt;;\n  return (\n    &lt;ul&gt;\n      {users.map(user =&gt; &lt;li key={user.id}&gt;{user.name} ({user.email})&lt;/li&gt;)}\n    &lt;/ul&gt;\n  );\n}</code></pre><p>✅ <strong>Мета:</strong> студенти повинні навчитися:</p><ul><li>Виконувати HTTP-запити через Axios.</li><li>Обробляти відповіді та помилки запитів.</li><li>Інтегрувати асинхронні дані у React-компоненти.</li><li>Використовувати interceptors для авторизації та глобальної обробки помилок.</li><li>Обʼєднувати кілька запитів та оптимізувати API-виклики.</li></ul><!-- Axios: HTTP requests, async/await, interceptors, React integration -->",

    "lesson9": "<h2>Урок 9 – TailwindCSS + Prettier: сучасне оформлення та чистий код</h2><p>У цьому уроці розглянемо, як використовувати <strong>TailwindCSS</strong> для швидкої та гнучкої стилізації компонентів React та <strong>Prettier</strong> для автоматичного форматування коду. Це дозволяє писати красивий, підтримуваний та консистентний код без ручного налаштування CSS.</p><h3>TailwindCSS – основні концепції:</h3><ul><li>Утилітарний підхід: класи для стилізації елементів напряму в JSX (<code>className=\"bg-blue-500 text-white p-4 rounded\"</code>).</li><li>Композиція класів: комбінування кольорів, відступів, шрифтів, flex/grid-системи та responsive design (<code>sm:, md:, lg:</code>).</li><li>Медіа-запити і адаптивний дизайн за допомогою breakpoint-класів.</li><li>Псевдокласи: <code>hover:</code>, <code>focus:</code>, <code>active:</code> тощо.</li><li>Темізація та dark mode через <code>dark:</code> класи.</li></ul><h3>Prettier – автоматичне форматування:</h3><ul><li>Підключення через <code>npm install --save-dev prettier</code> або інтеграція у редактор (VSCode).</li><li>Автоформатування JSX, JS/TS, JSON, CSS, Tailwind-класів.</li><li>Конфігурація через <code>.prettierrc</code> для стилю коду (відступи, лапки, крапки з комою).</li><li>Інтеграція з ESLint для підтримки чистого і консистентного коду.</li></ul><h3>Приклад Tailwind + React:</h3><pre><code>function Card({ title, description }) {\n  return (\n    &lt;div className=\"max-w-sm mx-auto bg-white shadow-lg rounded-lg p-6 hover:shadow-xl transition-shadow duration-300\"\n    &gt;\n      &lt;h3 className=\"text-xl font-bold mb-2 text-gray-800\"&gt;{title}&lt;/h3&gt;\n      &lt;p className=\"text-gray-600\"&gt;{description}&lt;/p&gt;\n      &lt;button className=\"mt-4 bg-blue-500 text-white px-4 py-2 rounded hover:bg-blue-600\"&gt;Детальніше&lt;/button&gt;\n    &lt;/div&gt;\n  );\n}</code></pre><h3>Prettier конфігурація:</h3><pre><code>{\n  \"semi\": true,\n  \"singleQuote\": true,\n  \"tabWidth\": 2,\n  \"trailingComma\": \"es5\",\n  \"printWidth\": 80\n}</code></pre><p>✅ <strong>Мета:</strong> студенти повинні навчитися:</p><ul><li>Стилізувати компоненти швидко та ефективно за допомогою TailwindCSS.</li><li>Створювати адаптивні та красиві UI без писання звичайного CSS.</li><li>Підключати і налаштовувати Prettier для автоматичного форматування коду.</li><li>Підтримувати консистентний стиль коду в командних проектах.</li><li>Інтегрувати Tailwind та Prettier у React-проєкти без конфліктів.</li></ul><!-- TailwindCSS + Prettier: utility-first styling, responsive design, code formatting -->",

    "lesson10": "<h2>Урок 10 – i18Next: Локалізація React-застосунків</h2><p>i18Next — потужна бібліотека для реалізації багатомовності у React-проєктах. Вона дозволяє динамічно змінювати мову, підвантажувати переклади та керувати форматуванням чисел, дат і часу.</p><h3>Основні концепції:</h3><ul><li>Структура перекладів: JSON-файли для кожної мови (<code>en.json</code>, <code>uk.json</code>).</li><li>Ініціалізація i18Next через <code>initReactI18next</code> та налаштування fallbackLng, defaultNS, resources.</li><li>Хук <code>useTranslation()</code> для отримання функції <code>t()</code> в компонентах.</li><li>Динамічна зміна мови через <code>i18n.changeLanguage('uk')</code>.</li><li>Форматування чисел, валют, дат і часу за допомогою <code>i18next.format()</code> та <code>react-i18next</code>.</li></ul><h3>Приклад:</h3><pre><code>// i18n.js\nimport i18n from 'i18next';\nimport { initReactI18next } from 'react-i18next';\nimport en from './locales/en.json';\nimport uk from './locales/uk.json';\n\ni18n.use(initReactI18next).init({\n  resources: { en: { translation: en }, uk: { translation: uk } },\n  lng: 'uk',\n  fallbackLng: 'en',\n  interpolation: { escapeValue: false },\n});\n\nexport default i18n;\n\n// App.jsx\nimport { useTranslation } from 'react-i18next';\n\nfunction App() {\n  const { t, i18n } = useTranslation();\n  return (\n    &lt;div&gt;\n      &lt;h1&gt;{t('welcome')} &lt;/h1&gt;\n      &lt;button onClick={() =&gt; i18n.changeLanguage('en')}&gt;EN&lt;/button&gt;\n      &lt;button onClick={() =&gt; i18n.changeLanguage('uk')}&gt;UK&lt;/button&gt;\n    &lt;/div&gt;\n  );\n}</code></pre><p>✅ <strong>Мета:</strong> студенти повинні навчитися:</p><ul><li>Ініціалізувати i18Next у React-проєкті.</li><li>Створювати та організовувати JSON-файли перекладів для різних мов.</li><li>Використовувати <code>useTranslation</code> та функцію <code>t()</code> у компонентах.</li><li>Динамічно змінювати мову інтерфейсу.</li><li>Локалізувати числа, дати та інші формати з урахуванням регіональних налаштувань.</li></ul><!-- i18Next: localization, multi-language, React integration -->",

    "lesson11": "<h2>Урок 11 – Фінальний проект: React, TypeScript/JS та управління станом</h2><p>Мета цього уроку – об'єднати всі знання курсу у реальному проєкті. Студенти створюють SPA на React з використанням сучасних технологій, GitHub та управлінням станом.</p><h3>Вимоги до проєкту:</h3><ol><li><strong>GitHub:</strong> робота з гілками та репозиторіями (створення feature-branch, merge, pull request).</li><li><strong>React:</strong> використання функціональних компонентів, хуків та компонентної архітектури.</li><li><strong>Мова:</strong> TypeScript або JavaScript на вибір студента.</li><li><strong>Стилизація:</strong> SCSS або TailwindCSS для оформлення UI.</li><li><strong>Сторінки:</strong> мінімум 2 сторінки (наприклад, головна + профіль/деталі).</li><li><strong>Task Management:</strong> робота з Trello або Jira для планування завдань (не обов'язково, але рекомендовано).</li><li><strong>Стан застосунку:</strong> обов'язково використати Redux Toolkit (RTK) або Zustand для керування глобальним станом.</li></ol><h3>Структура команд:</h3><ul><li>Створити головну гілку <code>main</code> (production-ready).</li><li>Для кожної фічі – окремий <code>feature/назва</code> гілку.</li><li>Використовувати pull request для інтеграції змін у <code>main</code>.</li><li>Обов'язкове коментування комітів згідно з best practices.</li><li>Делегування завдань у команді через Trello/Jira (опціонально).</li></ul><h3>Мета та навчальні цілі:</h3><ul><li>Закріпити навички роботи з React та хуками.</li><li>Практично застосувати TypeScript або JavaScript у реальному проєкті.</li><li>Навчитися працювати з GitHub, гілками та pull requests.</li><li>Розуміти і використовувати глобальний стан через RTK або Zustand.</li><li>Створювати адаптивний та гарний UI через SCSS або Tailwind.</li><li>Організовувати роботу команди та задачі проекту.</li></ul><!-- Final Project: React, TS/JS, GitHub, RTK/Zustand, multi-page SPA -->",

    "lesson12": "<h2>Урок 12 – Loading та Material-UI (MUI) компоненти</h2><p>У цьому уроці розглянемо, як показувати стан завантаження даних у React та використовувати <strong>Material-UI (MUI)</strong> для готових компонентів інтерфейсу. Це допомагає робити застосунки більш інтерактивними та користувацько-дружніми.</p><h3>Loading – концепції:</h3><ul><li>Використання локального стану <code>useState</code> для контролю завантаження.</li><li>Показ спінерів або індикаторів під час запитів до API.</li><li>Обробка асинхронних функцій через <code>async/await</code> або проміси.</li><li>Використання логіки відображення умовно: <code>loading ? &lt;Spinner /&gt; : &lt;Content /&gt;</code>.</li></ul><h3>Material-UI – основні компоненти для Loading:</h3><ul><li><strong>CircularProgress</strong> – круговий спінер.</li><li><strong>LinearProgress</strong> – лінійний прогрес-бар.</li><li><strong>Skeleton</strong> – заповнювач контенту до його завантаження.</li><li>Інтеграція MUI з кнопками, картками та таблицями для покращення UX.</li></ul><h3>Приклад використання:</h3><pre><code>import { useState, useEffect } from 'react';\nimport { CircularProgress, Button, Card, CardContent, Typography } from '@mui/material';\n\nfunction UserCard() {\n  const [user, setUser] = useState(null);\n  const [loading, setLoading] = useState(true);\n\n  useEffect(() =&gt; {\n    const fetchUser = async () =&gt; {\n      try {\n        const res = await fetch('https://jsonplaceholder.typicode.com/users/1');\n        const data = await res.json();\n        setUser(data);\n      } catch (err) {\n        console.error(err);\n      } finally {\n        setLoading(false);\n      }\n    };\n    fetchUser();\n  }, []);\n\n  if (loading) return &lt;CircularProgress /&gt;;\n\n  return (\n    &lt;Card sx={{ maxWidth: 300, m: 2 }}&gt;\n      &lt;CardContent&gt;\n        &lt;Typography variant='h6'&gt;{user.name}&lt;/Typography&gt;\n        &lt;Typography color='text.secondary'&gt;{user.email}&lt;/Typography&gt;\n        &lt;Button variant='contained' sx={{ mt: 1 }}&gt;Написати&lt;/Button&gt;\n      &lt;/CardContent&gt;\n    &lt;/Card&gt;\n  );\n}</code></pre><p>✅ <strong>Мета:</strong> студенти повинні навчитися:</p><ul><li>Відображати стан завантаження даних у React-компонентах.</li><li>Використовувати Material-UI для швидкого створення UI елементів.</li><li>Інтегрувати Loading компоненти з реальними асинхронними запитами.</li><li>Покращувати користувацький досвід через індикатори прогресу та скелетони.</li></ul><!-- Loading, Material-UI (MUI), CircularProgress, LinearProgress, Skeleton, React integration -->",

    "lesson13": "<h2>Урок 13 – Анімації у React за допомогою Framer Motion</h2><p>Framer Motion — потужна бібліотека для створення плавних анімацій у React. Вона дозволяє анімувати компоненти без складних CSS, керувати станами анімацій та створювати інтерактивний UX.</p><h3>Основні концепції:</h3><ul><li>Компоненти <code>motion.div</code>, <code>motion.button</code> для анімації елементів.</li><li>Властивості анімацій: <code>animate</code>, <code>initial</code>, <code>exit</code>.</li><li>Транзіції через <code>transition</code> (duration, delay, ease).</li><li>Анімація при hover та tap через <code>whileHover</code>, <code>whileTap</code>.</li><li>Контейнерні анімації та staggered effects через <code>AnimatePresence</code> для додавання/видалення компонентів з анімацією.</li></ul><h3>Приклад:</h3><pre><code>import { motion, AnimatePresence } from 'framer-motion';\nimport { useState } from 'react';\n\nfunction AnimatedCard({ show }) {\n  return (\n    &lt;AnimatePresence&gt;\n      {show &amp;&amp; (\n        &lt;motion.div\n          initial={{ opacity: 0, y: -20 }}\n          animate={{ opacity: 1, y: 0 }}\n          exit={{ opacity: 0, y: 20 }}\n          transition={{ duration: 0.5 }}\n          style={{ background: '#f0f0f0', padding: '20px', borderRadius: '8px', margin: '10px' }}\n        &gt;\n          Привіт, я анімований!\n        &lt;/motion.div&gt;\n      )}\n    &lt;/AnimatePresence&gt;\n  );\n}\n\nexport default function App() {\n  const [show, setShow] = useState(true);\n  return (\n    &lt;div&gt;\n      &lt;button onClick={() =&gt; setShow(prev =&gt; !prev)}&gt;Toggle Card&lt;/button&gt;\n      &lt;AnimatedCard show={show} /&gt;\n    &lt;/div&gt;\n  );\n}</code></pre><p>✅ <strong>Мета:</strong> студенти повинні навчитися:</p><ul><li>Створювати плавні анімації у React-компонентах за допомогою Framer Motion.</li><li>Використовувати <code>motion</code> компоненти та властивості <code>initial</code>, <code>animate</code>, <code>exit</code>.</li><li>Керувати транзіціями та ефектами hover/tap.</li><li>Анімувати додавання і видалення елементів через <code>AnimatePresence</code>.</li><li>Створювати інтерактивний та приємний UX без складного CSS.</li></ul><!-- Framer Motion: React animations, AnimatePresence, motion components, transitions, hover/tap effects -->",

    "lesson14": "<h2>Урок 14 – React Forms: керування формами та валідація</h2><p>Форми у React є основним способом збору даних від користувача. Цей урок охоплює контрольовані та неконтрольовані компоненти, керування станом форми та базову валідацію.</p><h3>Основні концепції:</h3><ul><li><strong>Контрольовані компоненти:</strong> значення input-ів зберігається у state через <code>useState</code> і оновлюється через <code>onChange</code>.</li><li><strong>Неконтрольовані компоненти:</strong> використання <code>useRef</code> для прямого доступу до DOM елементів.</li><li><strong>Обробка подій submit:</strong> <code>onSubmit</code> для отримання даних форми та запобігання перезавантаженню сторінки.</li><li><strong>Валідація:</strong> базова перевірка полів (required, email, min/max length) та показ повідомлень про помилки.</li><li><strong>Формові бібліотеки:</strong> можливе використання <code>react-hook-form</code> або Formik для спрощення керування формами та валідації.</li></ul><h3>Приклад контрольованої форми:</h3><pre><code>import { useState } from 'react';\n\nfunction ContactForm() {\n  const [form, setForm] = useState({ name: '', email: '' });\n  const [errors, setErrors] = useState({});\n\n  const handleChange = e =&gt; {\n    setForm({ ...form, [e.target.name]: e.target.value });\n  };\n\n  const validate = () =&gt; {\n    const errs = {};\n    if (!form.name) errs.name = 'Ім’я обов’язкове';\n    if (!form.email) errs.email = 'Email обов’язковий';\n    else if (!/^[^@]+@[^@]+\\.[^@]+$/.test(form.email)) errs.email = 'Некоректний email';\n    setErrors(errs);\n    return Object.keys(errs).length === 0;\n  };\n\n  const handleSubmit = e =&gt; {\n    e.preventDefault();\n    if (validate()) {\n      console.log('Форма відправлена:', form);\n      setForm({ name: '', email: '' });\n    }\n  };\n\n  return (\n    &lt;form onSubmit={handleSubmit}&gt;\n      &lt;div&gt;\n        &lt;input name='name' value={form.name} onChange={handleChange} placeholder='Ім’я' /&gt;\n        &lt;span style={{ color: 'red' }}&gt;{errors.name}&lt;/span&gt;\n      &lt;/div&gt;\n      &lt;div&gt;\n        &lt;input name='email' value={form.email} onChange={handleChange} placeholder='Email' /&gt;\n        &lt;span style={{ color: 'red' }}&gt;{errors.email}&lt;/span&gt;\n      &lt;/div&gt;\n      &lt;button type='submit'&gt;Відправити&lt;/button&gt;\n    &lt;/form&gt;\n  );\n}</code></pre><p>✅ <strong>Мета:</strong> студенти повинні навчитися:</p><ul><li>Створювати контрольовані та неконтрольовані форми у React.</li><li>Керувати станом полів через <code>useState</code> та <code>useRef</code>.</li><li>Реалізовувати базову валідацію та показ повідомлень про помилки.</li><li>Обробляти події submit та інтегрувати форми з API або локальним станом.</li><li>Використовувати бібліотеки для форм (<code>react-hook-form</code>, Formik) для масштабних застосунків.</li></ul><!-- React Forms: controlled, uncontrolled, validation, submit, react-hook-form, Formik -->",

    "lesson15": "<h2>Урок 15 – Фінальний тест: JavaScript, React, TypeScript та суміжні технології</h2><p>Цей тест перевіряє знання студентів у всіх ключових темах курсу: JS, DOM, HTML/CSS, Flexbox, Git, React, TypeScript, TailwindCSS, Redux Toolkit, Axios, i18n та React Router. Студенти повинні дати теоретичні відповіді та виконати практичні завдання.</p><h3>JavaScript та DOM</h3><ol><li>Що таке DOM і як з ним взаємодіяти у JavaScript?</li><li>Напишіть код для додавання нового елемента &lt;li&gt; до списку &lt;ul id='list'&gt;.</li><li>Чим відрізняються let, const та var?</li><li>Опишіть різницю між масивом та об’єктом у JS. Наведіть приклади.</li><li>Практичне завдання: Напишіть функцію, яка приймає масив чисел і повертає відсортований масив.</li></ol><h3>HTML/CSS та Flexbox</h3><ol start='6'><li>Що таке Flexbox? Напишіть приклад верстки з його використанням.</li><li>Які є основні властивості Flexbox-контейнера та їх призначення?</li><li>Створіть HTML-форму з полями: ім’я, email та кнопкою “Відправити”.</li><li>Практичне завдання: Верстати просту сторінку з навігаційним меню за допомогою Flexbox.</li></ol><h3>Git та GitHub</h3><ol start='10'><li>Поясніть основні команди Git: git add, git commit, git push.</li><li>Що таке git merge та git rebase?</li><li>Практичне завдання: Ініціалізуйте Git-репозиторій, додайте файл index.html і зробіть коміт.</li></ol><h3>React та суміжні технології</h3><ol start='13'><li>Напишіть приклад простого React-компонента, що відображає “Привіт, світ!”.</li><li>Що таке props і state в React? Поясніть відмінність.</li><li>Як працює useEffect? Наведіть приклад використання.</li><li>Практичне завдання: Створіть React-компонент To-Do List з можливістю додавати та видаляти завдання.</li></ol><h3>TypeScript</h3><ol start='17'><li>Чим TypeScript відрізняється від JavaScript?</li><li>Оголосіть тип для масиву рядків у TypeScript.</li><li>Практичне завдання: Напишіть інтерфейс User з полями id, name та email.</li></ol><h3>TailwindCSS</h3><ol start='20'><li>Які переваги TailwindCSS перед звичайним CSS?</li><li>Напишіть приклад кнопки, стилізованої за допомогою TailwindCSS.</li><li>Практичне завдання: Створіть картку профілю користувача з TailwindCSS.</li></ol><h3>Redux Toolkit (RTK)</h3><ol start='23'><li>Що таке Redux Toolkit і чому його використовують?</li><li>Напишіть приклад створення slice в RTK.</li><li>Практичне завдання: Реалізуйте лічильник за допомогою Redux Toolkit.</li></ol><h3>Axios та робота з API</h3><ol start='26'><li>Як за допомогою Axios виконати GET-запит? Напишіть приклад.</li><li>Що таке interceptors в Axios?</li><li>Практичне завдання: Напишіть функцію, що виконує POST-запит через Axios.</li></ol><h3>i18n, React Router</h3><ol start='29'><li>Що таке i18n і як його застосувати в React?</li><li>Напишіть приклад налаштування маршруту в React Router.</li><li>Практичне завдання: Реалізуйте навігацію між двома сторінками за допомогою React Router.</li></ol><p>ВАШІ ВІДПОВІДІ: <br>----------------------------------------------------------------------------------------------------------------------<br>1 – <br>2 – <br>3 – <br>4 – <br>5 – <br>6 – <br>7 – <br>8 – <br>9 – <br>10 – <br>11 – <br>12 – <br>13 – <br>14 – <br>15 – <br>16 – <br>17 – <br>18 – <br>19 – <br>20 – <br>21 – <br>22 – <br>23 – <br>24 – <br>25 – <br>26 – <br>27 – <br>28 – <br>29 – <br>30 – <br>31 – </p><!-- Final test covering JS, DOM, HTML/CSS, Flexbox, Git, React, TS, Tailwind, RTK, Axios, i18n, React Router -->",

    "lesson16": "<h2>Урок 16 – Підсумок курсу та перевірка фінальних проектів</h2><p>Цей урок підсумовує весь пройдений матеріал, дозволяє студентам показати свої фінальні проєкти, отримати фідбек і закріпити знання у практиці.</p><h3>Основні завдання уроку:</h3><ul><li>Презентація фінальних проектів студентів.</li><li>Перевірка коду: структура, чистота коду, використання сучасних технологій (React, TS/JS, Tailwind/SCSS, RTK/Zustand, i18n, React Router, Axios).</li><li>Оцінка UI/UX: адаптивність, зручність використання, дизайн та анімації (Framer Motion).</li><li>Фідбек щодо GitHub workflow: коміти, гілки, pull requests.</li><li>Розбір помилок та рекомендації для оптимізації коду та архітектури.</li><li>Обговорення труднощів, з якими зіткнулися студенти, та варіанти їх вирішення.</li></ul><h3>Мета уроку:</h3><ul><li>Закріпити всі практичні навички курсу у реальному проєкті.</li><li>Навчитися робити презентацію власного коду та обґрунтовувати рішення.</li><li>Отримати конструктивний фідбек від викладача та колег.</li><li>Підвищити впевненість у використанні всіх вивчених технологій.</li><li>Сформувати розуміння стандартів командної розробки та best practices у React-проєктах.</li></ul><!-- Course Summary: final project review, code quality, UI/UX evaluation, GitHub workflow, constructive feedback -->",

}

const lessonsContainer = document.getElementById("lessons-grid");
const viewer = document.getElementById("lesson-viewer");
const viewerTitle = document.getElementById("viewer-title");
const viewerText = document.getElementById("viewer-text");
const backBtn = document.getElementById("back-btn");

Object.keys(lessonsContent).forEach(lessonId => {
    const fileDiv = document.createElement("div");
    fileDiv.className = "file";
    fileDiv.dataset.id = lessonId;

    const tempDiv = document.createElement("div");
    tempDiv.innerHTML = lessonsContent[lessonId];
    const title = tempDiv.querySelector("h2")?.textContent || lessonId;

    fileDiv.textContent = `📄 ${title}`;
    lessonsContainer.appendChild(fileDiv);

    fileDiv.addEventListener("click", () => {
        viewerTitle.textContent = title;
        viewerText.innerHTML = lessonsContent[lessonId];
        lessonsContainer.classList.add("hidden");
        viewer.classList.remove("hidden");
    });
});

backBtn.addEventListener("click", () => {
    viewer.classList.add("hidden");
    lessonsContainer.classList.remove("hidden");
});