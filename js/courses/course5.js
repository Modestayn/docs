const lessonContainer = document.getElementById('lesson-container')
const lessonsGrid = document.getElementById('lessons-grid')
const lessonsContent = {
    lesson1: "<h2>Урок 1 – Створення калькулятора: знайомство з React, JSX, компонентами та станом</h2><p>У цьому уроці студенти створять простий калькулятор на React, який покаже базові концепції JSX, функціональних компонентів, управління станом за допомогою <code>useState</code> та обробки подій.</p><h3>Основні можливості:</h3><ul><li>Створення функціонального компонента.</li><li>Використання JSX для опису UI.</li><li>Керування локальним станом через <code>useState</code>.</li><li>Обробка подій (натискання кнопок) і оновлення інтерфейсу.</li></ul><h3>Приклад:</h3><pre><code>import React, { useState } from 'react'; function Calculator(){ const [display, setDisplay] = useState(''); const append = val => setDisplay(prev => prev + val); const clear = () => setDisplay(''); const calc = () => { try { /* простий приклад: eval лише для навчання, у продакшні — безпечні парсери */ setDisplay(String(eval(display))); } catch { setDisplay('Error'); } }; return (<div className='calculator'><input readOnly value={display} /><div className='keys'><button onClick={() => append('1')}>1</button><button onClick={() => append('2')}>2</button><button onClick={() => append('3')}>3</button><button onClick={() => append('+')}>+</button><button onClick={() => append('4')}>4</button><button onClick={() => append('5')}>5</button><button onClick={() => append('6')}>6</button><button onClick={() => append('-')}>-</button><button onClick={() => append('7')}>7</button><button onClick={() => append('8')}>8</button><button onClick={() => append('9')}>9</button><button onClick={() => append('*')}>*</button><button onClick={() => append('0')}>0</button><button onClick={clear}>C</button><button onClick={calc}>=</button><button onClick={() => append('/')}>/</button></div></div>); } export default Calculator;</code></pre><p>✅ <strong>Мета:</strong> студенти повинні навчитися створювати інтерактивні компоненти на React, розуміти роль JSX і локального стану, а також безпечно обробляти події та оновлювати інтерфейс.</p><ul><li>Практичне: зібрати робочий калькулятор.</li><li>Теоретичне: відрізняти props від state.</li><li>Безпека: чому <code>eval</code> — не для продакшну і як його замінити.</li></ul><!-- Бібліотека: react -->",

    lesson2: "<h2>Урок 2 – Tanstack Query: робота з асинхронними даними, кешування та запити</h2><p>Tanstack Query (раніше React Query) — це потужна бібліотека для керування асинхронними запитами та кешем у React-застосунках. Вона спрощує отримання, оновлення і повторне використання даних із серверів або API.</p><h3>Основні можливості:</h3><ul><li>Автоматичне кешування результатів запитів.</li><li>Повторне отримання даних при фокусі на вікні.</li><li>Індикація станів запиту: <code>loading</code>, <code>error</code>, <code>success</code>.</li><li>Оновлення даних без ручного виклику fetch.</li></ul><h3>Приклад:</h3><pre><code>import React from 'react'; import { useQuery, QueryClient, QueryClientProvider } from '@tanstack/react-query'; const client = new QueryClient(); function Todos(){ const { data, error, isLoading } = useQuery({ queryKey: ['todos'], queryFn: async () => { const res = await fetch('https://jsonplaceholder.typicode.com/todos'); return res.json(); } }); if(isLoading) return <p>Завантаження...</p>; if(error) return <p>Помилка: {error.message}</p>; return (<ul>{data.slice(0,5).map(todo => <li key={todo.id}>{todo.title}</li>)}</ul>); } export default function App(){ return (<QueryClientProvider client={client}><h2>Список завдань</h2><Todos /></QueryClientProvider>); }</code></pre><p>✅ <strong>Мета:</strong> студенти повинні навчитися:</p><ul><li>Використовувати <code>useQuery</code> для отримання даних.</li><li>Розуміти механізм кешування та повторного отримання.</li><li>Будувати UI, який реагує на різні стани запиту.</li><li>Застосовувати <code>QueryClientProvider</code> для глобального керування даними.</li></ul><!-- Бібліотека: @tanstack/react-query -->",

    lesson3: "<h2>Урок 3 – Zustand: простий менеджер стану та практика створення глобального стану</h2><p>Zustand — це легкий менеджер стану для React, який дозволяє просто створювати та керувати глобальними станами без зайвої складності. Його синтаксис інтуїтивно зрозумілий, а використання базується на хуках.</p><h3>Основні можливості:</h3><ul><li>Глобальний стан без контекстів і редʼюсерів.</li><li>Мінімалістичне API для створення сховища.</li><li>Підтримка селекторів для вибіркового оновлення компонентів.</li><li>Легка інтеграція з React Query або локальним сховищем.</li></ul><h3>Приклад:</h3><pre><code>import { create } from 'zustand';\n\nconst useCounterStore = create((set) => ({\n  count: 0,\n  increment: () => set((state) => ({ count: state.count + 1 })),\n  decrement: () => set((state) => ({ count: state.count - 1 })),\n}));\n\nfunction Counter() {\n  const { count, increment, decrement } = useCounterStore();\n  return (\n    <div>\n      <h2>Лічильник: {count}</h2>\n      <button onClick={increment}>+</button>\n      <button onClick={decrement}>-</button>\n    </div>\n  );\n}\n\nexport default Counter;</code></pre><p>✅ <strong>Мета:</strong> студенти повинні навчитися:</p><ul><li>Створювати та підключати глобальний стан за допомогою Zustand.</li><li>Керувати даними без використання Redux або Context API.</li><li>Розуміти принципи оновлення компонентів через селектори.</li><li>Будувати прості реактивні інтерфейси з глобальним станом.</li></ul><!-- Бібліотека: zustand -->",

    lesson4: "<h2>Урок 4 – Todo App без сервера: закріплення Zustand, передача пропсів і структура компонентів</h2><p>У цьому уроці студенти створять невеликий застосунок <strong>Todo App</strong> без бекенду, щоб закріпити знання про Zustand, роботу з компонентами та передачу пропсів. Це чудова практика для структурування коду і управління станом на рівні всього застосунку.</p><h3>Основні можливості:</h3><ul><li>Створення глобального стану для списку завдань через Zustand.</li><li>Передача пропсів між компонентами.</li><li>Організація структури застосунку на кілька компонентів.</li><li>Збереження стану у памʼяті браузера (опціонально через <code>persist</code> middleware).</li></ul><h3>Приклад:</h3><pre><code>import { create } from 'zustand';\n\nconst useTodoStore = create((set) => ({\n  todos: [],\n  addTodo: (text) => set((state) => ({ todos: [...state.todos, { id: Date.now(), text, done: false }] })),\n  toggleTodo: (id) => set((state) => ({ todos: state.todos.map(t => t.id === id ? { ...t, done: !t.done } : t) })),\n  removeTodo: (id) => set((state) => ({ todos: state.todos.filter(t => t.id !== id) })),\n}));\n\nfunction TodoItem({ todo, onToggle, onRemove }) {\n  return (\n    <li>\n      <span style={{ textDecoration: todo.done ? 'line-through' : 'none' }}>{todo.text}</span>\n      <button onClick={() => onToggle(todo.id)}>✓</button>\n      <button onClick={() => onRemove(todo.id)}>✕</button>\n    </li>\n  );\n}\n\nfunction TodoList() {\n  const { todos, toggleTodo, removeTodo } = useTodoStore();\n  return <ul>{todos.map(todo => <TodoItem key={todo.id} todo={todo} onToggle={toggleTodo} onRemove={removeTodo} />)}</ul>;\n}\n\nfunction AddTodo() {\n  const [text, setText] = React.useState('');\n  const addTodo = useTodoStore((state) => state.addTodo);\n  return (\n    <div>\n      <input value={text} onChange={(e) => setText(e.target.value)} placeholder='Нове завдання' />\n      <button onClick={() => { if (text) addTodo(text); setText(''); }}>Додати</button>\n    </div>\n  );\n}\n\nexport default function TodoApp() {\n  return (\n    <div>\n      <h2>Мій Todo App</h2>\n      <AddTodo />\n      <TodoList />\n    </div>\n  );\n}</code></pre><p>✅ <strong>Мета:</strong> студенти повинні навчитися:</p><ul><li>Застосовувати Zustand для управління списками даних.</li><li>Розділяти UI на логічні компоненти.</li><li>Передавати пропси між компонентами для взаємодії.</li><li>Розуміти, як організувати структуру застосунку без сервера.</li></ul><!-- Бібліотека: zustand, react -->",

    lesson5: "<h2>Урок 5 – ShadCN UI + Redux Toolkit: компоненти UI бібліотеки та базовий менеджер стану</h2><p>У цьому уроці студенти познайомляться з <strong>ShadCN UI</strong> — сучасною бібліотекою компонентів для React, а також навчаться використовувати <strong>Redux Toolkit</strong> для управління глобальним станом. Поєднання цих технологій дозволяє створювати стильні та керовані застосунки.</p><h3>Основні можливості:</h3><ul><li>Встановлення та використання компонентів із ShadCN UI.</li><li>Створення сховища стану за допомогою Redux Toolkit.</li><li>Підключення <code>Provider</code> для доступу до стану в усьому застосунку.</li><li>Звʼязок UI з Redux через <code>useSelector</code> і <code>useDispatch</code>.</li></ul><h3>Приклад:</h3><pre><code>import React from 'react';\nimport { Provider, useDispatch, useSelector } from 'react-redux';\nimport { configureStore, createSlice } from '@reduxjs/toolkit';\nimport { Button } from '@/components/ui/button';\n\nconst counterSlice = createSlice({\n  name: 'counter',\n  initialState: { value: 0 },\n  reducers: {\n    increment: (state) => { state.value += 1; },\n    decrement: (state) => { state.value -= 1; }\n  }\n});\n\nconst store = configureStore({ reducer: { counter: counterSlice.reducer } });\n\nfunction Counter() {\n  const dispatch = useDispatch();\n  const count = useSelector((state) => state.counter.value);\n  return (\n    <div className='flex flex-col items-center gap-2 p-4'>\n      <h2 className='text-xl font-semibold'>Лічильник: {count}</h2>\n      <div className='flex gap-2'>\n        <Button onClick={() => dispatch(counterSlice.actions.increment())}>+</Button>\n        <Button onClick={() => dispatch(counterSlice.actions.decrement())}>-</Button>\n      </div>\n    </div>\n  );\n}\n\nexport default function App() {\n  return (\n    <Provider store={store}>\n      <div className='p-6 max-w-sm mx-auto'>\n        <h1 className='text-2xl font-bold mb-4'>ShadCN + Redux Toolkit</h1>\n        <Counter />\n      </div>\n    </Provider>\n  );\n}</code></pre><p>✅ <strong>Мета:</strong> студенти повинні навчитися:</p><ul><li>Підключати ShadCN UI та використовувати його компоненти.</li><li>Налаштовувати Redux Toolkit для управління станом.</li><li>Використовувати <code>Provider</code>, <code>useSelector</code> і <code>useDispatch</code>.</li><li>Поєднувати сучасний UI з керуванням станом у React-застосунках.</li></ul><!-- Бібліотеки: shadcn/ui, @reduxjs/toolkit, react-redux -->",

    lesson6: "<h2>Урок 6–7 – Watchlist App: створення застосунку зі списком фільмів та анімаціями через Framer Motion</h2><p>У цьому уроці студенти створять <strong>Watchlist App</strong> — застосунок для збереження улюблених фільмів у список перегляду. Основна мета — навчитися поєднувати керування станом із візуальними анімаціями за допомогою <strong>Framer Motion</strong>.</p><h3>Основні можливості:</h3><ul><li>Створення списку фільмів (watchlist) із можливістю додавання та видалення.</li><li>Анімація появи, видалення та наведення елементів через <code>Framer Motion</code>.</li><li>Зберігання списку у локальному стані або Zustand.</li><li>Практика створення компонентів і побудови динамічного інтерфейсу.</li></ul><h3>Приклад:</h3><pre><code>import React from 'react';\nimport { motion, AnimatePresence } from 'framer-motion';\nimport { create } from 'zustand';\n\nconst useWatchlist = create((set) => ({\n  movies: [],\n  addMovie: (title) => set((state) => ({ movies: [...state.movies, { id: Date.now(), title }] })),\n  removeMovie: (id) => set((state) => ({ movies: state.movies.filter(m => m.id !== id) })),\n}));\n\nfunction MovieItem({ movie, onRemove }) {\n  return (\n    <motion.li layout initial={{ opacity: 0, y: 20 }} animate={{ opacity: 1, y: 0 }} exit={{ opacity: 0, x: -50 }} className='flex justify-between items-center p-2 border-b'>\n      <span>{movie.title}</span>\n      <button onClick={() => onRemove(movie.id)}>✕</button>\n    </motion.li>\n  );\n}\n\nfunction Watchlist() {\n  const { movies, removeMovie } = useWatchlist();\n  return (\n    <ul className='w-full max-w-md mx-auto'>\n      <AnimatePresence>\n        {movies.map((m) => (\n          <MovieItem key={m.id} movie={m} onRemove={removeMovie} />\n        ))}\n      </AnimatePresence>\n    </ul>\n  );\n}\n\nfunction AddMovie() {\n  const [title, setTitle] = React.useState('');\n  const addMovie = useWatchlist((state) => state.addMovie);\n  return (\n    <div className='flex gap-2 justify-center mb-4'>\n      <input className='border p-1 rounded' value={title} onChange={(e) => setTitle(e.target.value)} placeholder='Назва фільму' />\n      <button onClick={() => { if (title) addMovie(title); setTitle(''); }}>Додати</button>\n    </div>\n  );\n}\n\nexport default function WatchlistApp() {\n  return (\n    <div className='p-6 text-center'>\n      <h2 className='text-2xl font-bold mb-4'>🎬 Watchlist App</h2>\n      <AddMovie />\n      <Watchlist />\n    </div>\n  );\n}</code></pre><p>✅ <strong>Мета:</strong> студенти повинні навчитися:</p><ul><li>Створювати інтерактивні списки з анімацією за допомогою Framer Motion.</li><li>Використовувати Zustand або локальний стан для керування даними.</li><li>Розуміти принцип <em>AnimatePresence</em> для плавного додавання/видалення елементів.</li><li>Поєднувати функціональність і візуальні ефекти в одному застосунку.</li></ul><!-- Бібліотеки: framer-motion, zustand, react -->",

    lesson7: "<h2>Урок 8–9 – Task Manager: drag-and-drop функціонал із dnd-kit та переміщення задач між списками</h2><p>У цьому уроці студенти створять <strong>Task Manager</strong> із підтримкою drag-and-drop для переміщення задач між різними колонками (наприклад, To Do, In Progress, Done). Для цього використовується сучасна бібліотека <strong>dnd-kit</strong>, яка надає простий API для побудови гнучких систем перетягування.</p><h3>Основні можливості:</h3><ul><li>Реалізація drag-and-drop функціоналу за допомогою dnd-kit.</li><li>Переміщення задач між списками.</li><li>Управління станом через Zustand або локальний state.</li><li>Динамічна візуальна взаємодія без стороннього сервера.</li></ul><h3>Приклад:</h3><pre><code>import React from 'react';\nimport { DndContext, closestCenter } from '@dnd-kit/core';\nimport { arrayMove, SortableContext, useSortable, verticalListSortingStrategy } from '@dnd-kit/sortable';\nimport { CSS } from '@dnd-kit/utilities';\nimport { create } from 'zustand';\n\nconst useTaskStore = create((set) => ({\n  columns: {\n    todo: ['Підготувати звіт', 'Зробити ревʼю коду'],\n    progress: ['Створити макет UI'],\n    done: ['Налаштувати ESLint']\n  },\n  moveTask: (from, to, task) => set((state) => {\n    const newFrom = state.columns[from].filter((t) => t !== task);\n    const newTo = [...state.columns[to], task];\n    return { columns: { ...state.columns, [from]: newFrom, [to]: newTo } };\n  })\n}));\n\nfunction SortableItem({ id }) {\n  const { attributes, listeners, setNodeRef, transform, transition } = useSortable({ id });\n  const style = { transform: CSS.Transform.toString(transform), transition };\n  return <div ref={setNodeRef} style={style} {...attributes} {...listeners} className='p-2 bg-white rounded shadow mb-2 cursor-grab'>{id}</div>;\n}\n\nfunction Column({ id, tasks }) {\n  return (\n    <div className='w-1/3 p-3 bg-gray-100 rounded'>\n      <h3 className='font-semibold text-center mb-2'>{id.toUpperCase()}</h3>\n      <SortableContext items={tasks} strategy={verticalListSortingStrategy}>\n        {tasks.map((task) => (<SortableItem key={task} id={task} />))}\n      </SortableContext>\n    </div>\n  );\n}\n\nexport default function TaskManager() {\n  const { columns, moveTask } = useTaskStore();\n\n  const handleDragEnd = (event) => {\n    const { active, over } = event;\n    if (!over) return;\n    const from = Object.keys(columns).find((key) => columns[key].includes(active.id));\n    const to = over.id;\n    if (from && to && from !== to) moveTask(from, to, active.id);\n  };\n\n  return (\n    <div className='p-6'>\n      <h2 className='text-2xl font-bold text-center mb-4'>🧩 Task Manager</h2>\n      <DndContext collisionDetection={closestCenter} onDragEnd={handleDragEnd}>\n        <div className='flex gap-4 justify-center'>\n          {Object.entries(columns).map(([key, tasks]) => (\n            <div key={key}>\n              <Column id={key} tasks={tasks} />\n            </div>\n          ))}\n        </div>\n      </DndContext>\n    </div>\n  );\n}</code></pre><p>✅ <strong>Мета:</strong> студенти повинні навчитися:</p><ul><li>Використовувати бібліотеку dnd-kit для drag-and-drop у React.</li><li>Розуміти принципи сортування та переміщення елементів між списками.</li><li>Інтегрувати drag-and-drop із глобальним станом (Zustand).</li><li>Створювати інтерактивні інтерфейси з візуальним фідбеком.</li></ul><!-- Бібліотеки: @dnd-kit/core, @dnd-kit/sortable, zustand, react -->",

    lesson8: '<h2>Урок 10 – Теоретичний тест по уроках 1–9: перевірка знань перед фінальним етапом</h2><p>Цей урок присвячений підсумковій перевірці теоретичних знань, отриманих у попередніх темах курсу. Студенти мають продемонструвати розуміння ключових концепцій React, стану, запитів, UI-компонентів та інструментів оптимізації коду.</p><h3>Основні теми перевірки:</h3><ul><li>Декоратори та оптимізація коду Python.</li><li>React: компоненти, JSX, стан (<code>useState</code>).</li><li>Tanstack Query: робота з асинхронними даними та кешування.</li><li>Zustand: створення глобального стану та управління ним.</li><li>Практика Todo App без сервера.</li><li>ShadCN UI + Redux Toolkit: компоненти та state management.</li><li>Framer Motion: створення анімацій у React.</li><li>dnd-kit: реалізація drag-and-drop у Task Manager.</li></ul><h3>Приклад формату запитань:</h3><pre><code>1. Що таке декоратор у Python і для чого він використовується?\n2. Яка різниця між props і state у React?\n3. Як Tanstack Query кешує отримані дані?\n4. Як створити глобальний стан за допомогою Zustand?\n5. Яку роль відіграє Provider у Redux Toolkit?\n6. Для чого використовується компонент AnimatePresence у Framer Motion?\n7. Що забезпечує бібліотека dnd-kit?</code></pre><p>✅ <strong>Мета:</strong> студенти повинні:</p><ul><li>Повторити основні теоретичні аспекти попередніх тем.</li><li>Зрозуміти, як поєднуються інструменти у сучасному фронтенд-розробленні.</li><li>Підготуватися до фінального практичного проєкту.</li><li>Навчитися аргументовано пояснювати принципи роботи бібліотек і технологій.</li></ul><!-- Тип уроку: теоретичний тест, охоплення тем 1–9 -->',

    lesson9: "<h2>Урок 11–12 – Product List App: фільтрація, сортування та пошук по списку товарів на фронтенді</h2><p>У цьому уроці студенти створять інтерфейс для відображення списку продуктів з можливістю фільтрації за категоріями, сортування за ціною/рейтинґом і пошуку за назвою. Основна увага — оптимізація оновлень UI, робота з локальним станом та використання <code>useMemo</code> для уникнення зайвих перерендерів.</p><h3>Основні можливості:</h3><ul><li>Побудова списку товарів з даних у локальному масиві (можливо — mock API).</li><li>Пошук по назві з debounce для зменшення кількості операцій.</li><li>Фільтрація за категорією та сортування (за зростанням/спаданням ціни, рейтингу).</li><li>Оптимізація: <code>useMemo</code> для результатів фільтрації/сортування, <code>useCallback</code> для обробників.</li></ul><h3>Приклад:</h3><pre><code>import React from 'react';\n\nconst productsMock = [\n  { id: 1, name: 'Кросівки A', category: 'Взуття', price: 120, rating: 4.5 },\n  { id: 2, name: 'Футболка B', category: 'Одяг', price: 25, rating: 4.0 },\n  { id: 3, name: 'Штани C', category: 'Одяг', price: 60, rating: 4.2 },\n  { id: 4, name: 'Кепка D', category: 'Аксесуари', price: 15, rating: 3.8 },\n];\n\nfunction useDebounced(value, delay = 300) {\n  const [debounced, setDebounced] = React.useState(value);\n  React.useEffect(() => {\n    const id = setTimeout(() => setDebounced(value), delay);\n    return () => clearTimeout(id);\n  }, [value, delay]);\n  return debounced;\n}\n\nexport default function ProductListApp() {\n  const [query, setQuery] = React.useState('');\n  const [category, setCategory] = React.useState('All');\n  const [sortBy, setSortBy] = React.useState('none');\n\n  const debouncedQuery = useDebounced(query, 250);\n\n  const filtered = React.useMemo(() => {\n    let result = productsMock.slice();\n    if (category !== 'All') result = result.filter(p => p.category === category);\n    if (debouncedQuery) result = result.filter(p => p.name.toLowerCase().includes(debouncedQuery.toLowerCase()));\n    if (sortBy === 'price-asc') result.sort((a,b) => a.price - b.price);\n    if (sortBy === 'price-desc') result.sort((a,b) => b.price - a.price);\n    if (sortBy === 'rating-desc') result.sort((a,b) => b.rating - a.rating);\n    return result;\n  }, [category, debouncedQuery, sortBy]);\n\n  return (\n    <div className='p-6 max-w-3xl mx-auto'>\n      <h2 className='text-2xl font-bold mb-4'>🛍️ Product List</h2>\n\n      <div className='flex gap-3 mb-4'>\n        <input value={query} onChange={(e) => setQuery(e.target.value)} placeholder='Пошук товарів...' />\n        <select value={category} onChange={(e) => setCategory(e.target.value)}>\n          <option value='All'>Усі категорії</option>\n          <option value='Взуття'>Взуття</option>\n          <option value='Одяг'>Одяг</option>\n          <option value='Аксесуари'>Аксесуари</option>\n        </select>\n        <select value={sortBy} onChange={(e) => setSortBy(e.target.value)}>\n          <option value='none'>Без сортування</option>\n          <option value='price-asc'>Ціна: зростання</option>\n          <option value='price-desc'>Ціна: спадання</option>\n          <option value='rating-desc'>Рейтинг: спадання</option>\n        </select>\n      </div>\n\n      <ul className='grid grid-cols-1 gap-3'>\n        {filtered.map(p => (\n          <li key={p.id} className='p-3 border rounded flex justify-between items-center'>\n            <div>\n              <h3 className='font-semibold'>{p.name}</h3>\n              <p className='text-sm text-gray-600'>{p.category} • ⭐ {p.rating}</p>\n            </div>\n            <div className='text-right'>\n              <div className='font-bold'>{p.price}$</div>\n              <button className='mt-2'>Додати в кошик</button>\n            </div>\n          </li>\n        ))}\n      </ul>\n\n      {filtered.length === 0 && <p className='text-center mt-4 text-gray-500'>Товарів не знайдено</p>}\n    </div>\n  );\n}</code></pre><p>✅ <strong>Мета:</strong> студенти повинні навчитися:</p><ul><li>Реалізовувати пошук, фільтрацію та сортування на фронтенді без сервера.</li><li>Оптимізувати рендеринг із <code>useMemo</code> та debounce-пошук.</li><li>Проєктувати доступний та інтуїтивний інтерфейс для перегляду товарів.</li><li>За потреби інтегрувати цей UI з бекендом або Tanstack Query для реальних даних.</li></ul><!-- Бібліотеки: react -->",

    lesson10: '<h2>Урок 13 – Початок фінального проєкту: ідея, структура, компоненти та індивідуальна робота</h2><p>Цей урок відкриває фінальний етап курсу, де кожен студент розпочинає створення власного проєкту. Головна мета — застосувати всі вивчені інструменти (React, Zustand, Tanstack Query, Redux Toolkit, Framer Motion, dnd-kit тощо) у реальному проєкті, що має чітку структуру, функціональність і привабливий UI.</p><h3>Основні етапи:</h3><ul><li><strong>Вибір ідеї:</strong> студент самостійно обирає тему застосунку (наприклад, Task Board, Weather App, Expense Tracker, Movie Explorer тощо).</li><li><strong>Проєктування структури:</strong> визначення компонентів, маршрутів, стану, основних сторінок.</li><li><strong>Побудова UI:</strong> використання бібліотек ShadCN UI, Tailwind CSS, Framer Motion для створення сучасного інтерфейсу.</li><li><strong>Індивідуальна робота:</strong> кожен студент реалізує власну логіку, дизайн і структуру з урахуванням вимог.</li></ul><h3>Приклад структури проєкту:</h3><pre><code>src/\n ├── components/\n │    ├── Header.jsx\n │    ├── Sidebar.jsx\n │    └── ItemCard.jsx\n ├── pages/\n │    ├── Home.jsx\n │    ├── Details.jsx\n │    └── Settings.jsx\n ├── store/\n │    └── useAppStore.js\n ├── hooks/\n │    └── useFetchData.js\n ├── App.jsx\n └── main.jsx</code></pre><h3>Поради:</h3><ul><li>Почніть із <strong>мінімального функціоналу (MVP)</strong>, поступово додаючи нові можливості.</li><li>Створіть базову навігацію та структуру компонентів до початку стилізації.</li><li>Продумайте керування станом заздалегідь (Zustand або Redux Toolkit).</li><li>Документуйте свій код і розділіть його на логічні частини.</li></ul><p>✅ <strong>Мета:</strong> студенти повинні:</p><ul><li>Розробити індивідуальний план ідеї свого застосунку.</li><li>Побудувати базову структуру React-проєкту з компонентами.</li><li>Підготувати основу для інтеграції стану, API, анімацій та UI-компонентів.</li><li>Розпочати активну фазу створення фінального проєкту.</li></ul><!-- Тип уроку: практичний, підготовка до фінального проєкту -->',

    lesson11: "<h2>Урок 14 – Speed Booster: оптимізація продуктивності через lazy loading, мемоізацію та Suspense</h2><p>У цьому уроці студенти дізнаються, як підвищити продуктивність React-застосунків за допомогою <strong>lazy loading</strong>, <strong>React.memo</strong>, <strong>useMemo</strong>, <strong>useCallback</strong> і <strong>Suspense</strong>. Ці інструменти допомагають скоротити час завантаження, зменшити кількість непотрібних рендерів і зробити роботу інтерфейсу плавнішою.</p><h3>Основні можливості:</h3><ul><li>Використання <code>React.lazy()</code> і <code>Suspense</code> для динамічного імпорту компонентів.</li><li>Оптимізація повторних рендерів через <code>React.memo</code>.</li><li>Мемоізація обчислень і колбеків (<code>useMemo</code>, <code>useCallback</code>).</li><li>Покращення UX через Skeleton або fallback-завантажувачі.</li></ul><h3>Приклад:</h3><pre><code>import React, { Suspense, useState, useMemo, useCallback } from 'react';\n\nconst HeavyChart = React.lazy(() => import('./HeavyChart'));\n\nfunction ExpensiveList({ items }) {\n  console.log('Рендер списку');\n  const sorted = useMemo(() => [...items].sort(), [items]);\n  return <ul>{sorted.map((i) => <li key={i}>{i}</li>)}</ul>;\n}\n\nconst MemoList = React.memo(ExpensiveList);\n\nexport default function SpeedBooster() {\n  const [count, setCount] = useState(0);\n  const [data] = useState(['Банан', 'Апельсин', 'Яблуко']);\n\n  const increment = useCallback(() => setCount((c) => c + 1), []);\n\n  return (\n    <div className='p-6 text-center'>\n      <h2 className='text-2xl font-bold mb-4'>⚡ Speed Booster</h2>\n      <button onClick={increment} className='mb-4'>Клікни ({count})</button>\n\n      <Suspense fallback={<p>Завантаження графіка...</p>}>\n        <HeavyChart />\n      </Suspense>\n\n      <MemoList items={data} />\n    </div>\n  );\n}</code></pre><p>✅ <strong>Мета:</strong> студенти повинні навчитися:</p><ul><li>Використовувати lazy loading для асинхронного підвантаження компонентів.</li><li>Застосовувати мемоізацію для оптимізації обчислень і уникнення зайвих рендерів.</li><li>Працювати з <code>Suspense</code> і fallback-станами для покращення UX.</li><li>Розуміти різницю між оптимізацією рендерів та оптимізацією обчислень.</li></ul><!-- Бібліотека: react -->",

    lesson12: "<h2>Урок 15 – Booking Form App: багатокрокова форма, UX-флоу та перевірки даних</h2><p>У цьому уроці студенти створять <strong>Booking Form App</strong> — інтерактивну багатокрокову форму для бронювання (наприклад, подорожей, квитків або готелів). Основна мета — навчитися створювати зрозумілий UX-флоу, перевіряти введені дані та працювати з локальним станом для збереження прогресу користувача.</p><h3>Основні можливості:</h3><ul><li>Багатокрокова форма з переходами між етапами.</li><li>Перевірка даних користувача перед переходом до наступного кроку.</li><li>Збереження стану введених даних між кроками.</li><li>Використання компонентів для полів, кнопок і прогресу заповнення.</li></ul><h3>Приклад:</h3><pre><code>import React, { useState } from 'react';\n\nfunction Step1({ next, data, setData }) {\n  return (\n    <div>\n      <h3>Крок 1: Персональні дані</h3>\n      <input placeholder='Імʼя' value={data.name} onChange={(e) => setData({ ...data, name: e.target.value })} />\n      <input placeholder='Email' value={data.email} onChange={(e) => setData({ ...data, email: e.target.value })} />\n      <button disabled={!data.name || !data.email} onClick={next}>Далі</button>\n    </div>\n  );\n}\n\nfunction Step2({ next, back, data, setData }) {\n  return (\n    <div>\n      <h3>Крок 2: Деталі бронювання</h3>\n      <select value={data.room} onChange={(e) => setData({ ...data, room: e.target.value })}>\n        <option value=''>Оберіть тип номера</option>\n        <option value='single'>Одномісний</option>\n        <option value='double'>Двомісний</option>\n      </select>\n      <button onClick={back}>Назад</button>\n      <button disabled={!data.room} onClick={next}>Далі</button>\n    </div>\n  );\n}\n\nfunction Step3({ back, data }) {\n  return (\n    <div>\n      <h3>Крок 3: Підтвердження</h3>\n      <p><strong>Імʼя:</strong> {data.name}</p>\n      <p><strong>Email:</strong> {data.email}</p>\n      <p><strong>Тип номера:</strong> {data.room}</p>\n      <button onClick={back}>Назад</button>\n      <button onClick={() => alert('Бронювання підтверджено!')}>Підтвердити</button>\n    </div>\n  );\n}\n\nexport default function BookingFormApp() {\n  const [step, setStep] = useState(1);\n  const [data, setData] = useState({ name: '', email: '', room: '' });\n\n  return (\n    <div className='p-6 max-w-md mx-auto text-center'>\n      <h2 className='text-2xl font-bold mb-4'>🧾 Booking Form</h2>\n      <div className='mb-3'>Крок {step} із 3</div>\n      {step === 1 && <Step1 next={() => setStep(2)} data={data} setData={setData} />}\n      {step === 2 && <Step2 next={() => setStep(3)} back={() => setStep(1)} data={data} setData={setData} />}\n      {step === 3 && <Step3 back={() => setStep(2)} data={data} />}\n    </div>\n  );\n}</code></pre><p>✅ <strong>Мета:</strong> студенти повинні навчитися:</p><ul><li>Створювати багатокрокові форми з контролем переходів.</li><li>Організовувати UX-флоу із збереженням введених даних.</li><li>Виконувати перевірку полів перед переходом до наступного кроку.</li><li>Планувати структуру компонентів для великих форм.</li></ul><!-- Бібліотека: react -->",

    lesson13: '<h2>Урок 16 – Презентація фінального проєкту: демонстрація, перевірка та фідбек</h2><p>Цей заключний урок присвячений <strong>презентації фінального проєкту</strong>. Студенти демонструють свої роботи, показують функціонал, архітектуру, дизайн і технології, які вони застосували. Основна мета — оцінити результати навчання, отримати зворотний зв’язок і підсумувати весь курс.</p><h3>Основні етапи:</h3><ul><li><strong>Презентація проєкту:</strong> короткий огляд ідеї, показ головних можливостей і користувацького флоу.</li><li><strong>Демонстрація коду:</strong> пояснення структури, організації стану, використання бібліотек і патернів.</li><li><strong>Перевірка проєкту:</strong> тестування основного функціоналу, UI/UX та адаптивності.</li><li><strong>Фідбек:</strong> отримання порад від викладача та колег, обговорення можливих покращень.</li></ul><h3>Приклад структури презентації:</h3><pre><code>1️⃣ Ідея: короткий опис проблеми, яку вирішує застосунок.\n2️⃣ Функціонал: що може користувач зробити в застосунку.\n3️⃣ Технічна частина: бібліотеки, інструменти, структура компонентів.\n4️⃣ Демонстрація: показ UI і основних сценаріїв.\n5️⃣ Підсумки: чого вдалося навчитися та що можна вдосконалити.</code></pre><h3>Поради для презентації:</h3><ul><li>Підготуйте короткий сценарій демонстрації (до 5 хвилин).</li><li>Покажіть ключові фічі, а не весь код.</li><li>Звертайте увагу на UX, анімації та плавність роботи застосунку.</li><li>Продемонструйте, як ви застосували React, Zustand, Redux Toolkit, Tanstack Query або інші інструменти з курсу.</li></ul><p>✅ <strong>Мета:</strong> студенти повинні:</p><ul><li>Представити свій фінальний проєкт публічно.</li><li>Пояснити технічні рішення, які вони приймали під час розробки.</li><li>Отримати конструктивний фідбек і зрозуміти напрями для розвитку.</li><li>Підсумувати свій шлях у курсі та визначити наступні кроки у вивченні фронтенду.</li></ul><!-- Тип уроку: презентаційний, завершальний -->',
};
const lessonsContainer = document.getElementById("lessons-grid");
const viewer = document.getElementById("lesson-viewer");
const viewerTitle = document.getElementById("viewer-title");
const viewerText = document.getElementById("viewer-text");
const backBtn = document.getElementById("back-btn");

Object.keys(lessonsContent).forEach(lessonId => {
    const fileDiv = document.createElement("div");
    fileDiv.className = "file";
    fileDiv.dataset.id = lessonId;

    const tempDiv = document.createElement("div");
    tempDiv.innerHTML = lessonsContent[lessonId];
    const title = tempDiv.querySelector("h2") ?.textContent || lessonId;

    fileDiv.textContent = `📄 ${title}`;
    lessonsContainer.appendChild(fileDiv);

    fileDiv.addEventListener("click", () => {
        viewerTitle.textContent = title;
        viewerText.innerHTML = lessonsContent[lessonId];
        lessonsContainer.classList.add("hidden");
        viewer.classList.remove("hidden");
    });
});

backBtn.addEventListener("click", () => {
    viewer.classList.add("hidden");
    lessonsContainer.classList.remove("hidden");
});