Урок 3 – Функції: стрілочні, звичайні, замикання, інкапсуляція
У цьому уроці детально розберемо типи функцій у JavaScript, їх відмінності, як передавати значення, коллбеки, замикання і як робити інкапсуляцію.

1. Звичайні функції (function declaration та function expression)
Опис: є два частих способи оголосити звичайну функцію: function declaration (function foo(a,b){...}) та function expression (const foo = function(a,b){...}). Function declaration піднімається (hoisted) — її можна викликати до оголошення в коді; function expression піднімається як змінна, тому виклик до оголошення призведе до помилки. Звичайні функції мають свій контекст this (визначається тим, як функцію викликали), мають доступ до об’єкта arguments, їх можна використовувати як конструктори з new або робити генераторами (function*).

Приклад
function add(a,b){return a+b;} const sub = function(a,b){return a-b;}
2. Стрілочні функції
Опис: синтаксично коротші: const f = (a,b) => a+b;. Якщо тіло — один вираз, return не потрібен; для блочного тіла використовуються фігурні дужки і явний return. Стрілочні функції не мають власного this — вони лексично захоплюють this з зовнішнього контексту; також вони не мають власного arguments, не можуть бути конструкторами (new з ними не працює) і не можуть бути генераторами.

Приклад
const sum = (a,b) => a+b; const greet = name => 'Привіт, '+name;
3. Головні відмінності
this: звичайні функції мають динамічний this; стрілочні — лексичний (використовують this зовнішнього оточення).
arguments: доступний у звичайних; у стрілочних його немає (можна використовувати rest-параметри ...args).
hoisting: декларації піднімаються; функціональні вирази як змінні — ні.
конструктор: звичайні функції можуть бути викликані з new; стрілочні — ні.
4. Коллбеки
Коллбек — функція, яку передають як аргумент іншій функції для виклику пізніше. Використовується для подій, обробки результатів або асинхронної роботи. Коллбеки бувають синхронні і асинхронні. Недолік: велика вкладеність (callback-hell), через що з'явилися Promises і async/await.

Приклад синхронного коллбека
function repeat(n,fn){for(let i=0;i<n;i++){fn(i);}} repeat(3,i => console.log(i));
Приклад асинхронного коллбека
setTimeout(() => console.log('через 1с'),1000);
У Node-патерні часто використовують error-first callbacks: fn(err, result), але в сучасному коді частіше застосовують Promises/async-await для читабельності.

5. Передавання значень у функції
У JavaScript аргументи завжди передаються за значенням. Для примітивів (number, string, boolean, null, undefined, symbol) це копія значення — зміни всередині функції не впливають на зовнішню змінну. Для об'єктів і масивів передається копія посилання на об'єкт: якщо функція мутує внутрішній стан об'єкта (наприклад, змінює властивості), ці зміни будуть видимі зовні; якщо ж параметр переприсвоїти (param = {}), зовнішня змінна залишиться без змін.

Приклад
function changeNum(x){x=5;} let a=1; changeNum(a); // a все ще 1 function mutate(obj){obj.name='New';} const o={name:'Old'}; mutate(o); // o.name тепер 'New'
6. Замикання (closures)
Замикання — коли внутрішня функція пам'ятає лексичне оточення зовнішньої, навіть після того як зовнішня функція завершила виконання. Це дозволяє створювати приватні змінні і фабрики функцій.

Приклад лічильника
function counter(){let count=0; return function(){count++; return count;}} const c = counter(); c(); // 1 c(); // 2
Замикання часто використовують для інкапсуляції стану: зовнішній код не може напряму змінити приватну змінну, тільки через надані методи.

7. Інкапсуляція
Інкапсуляція в JS реалізується через замикання (функціональні модулі, IIFE), або через класи з приватними полями (#privateField) та символи. Приклад: модуль, який повертає об'єкт з методами, але зберігає приватні змінні всередині замикання. Переваги: контроль доступу і захист від випадкових змін.

8. Практичні поради
Використовуйте стрілочні функції для коротких колбеків та коли потрібне лексичне this.
Використовуйте звичайні функції, якщо вам потрібен власний this, arguments або можливість бути конструктором.
Для приватних даних застосовуйте замикання або приватні поля класів.
Уникайте мутацій вхідних об'єктів — робіть копії, якщо потрібно.
Для асинхронності віддавайте перевагу Promises/async-await замість глибоких вкладених коллбеків.
9. Короткий приклад різниці this
const obj = {val:10, method:function(){return this.val;}, arrow:() => this.val}; obj.method(); // 10 obj.arrow(); // undefined або глобальний this
Висновок
Функції в JS дуже гнучкі: стрілочні дають компактність і стабільний лексичний this, звичайні функції надають більше можливостей (hoisting, arguments, конструктор). Замикання і інкапсуляція дозволяють будувати безпечні модулі з приватним станом. Коллбеки корисні, але для читабельності асинхронного коду краще використовувати Promises та async/await.